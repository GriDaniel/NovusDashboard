{"version":3,"sources":["ColumnModule.js","DropdownModule.js","PaginationModule.js","RowModule.js","SearchModule.js","SortIndicatorModule.js","TableDataModule.js","tableTitleModule.js"],"names":["ColumnManagerModule","let","instance","ColumnManager","constructor","ColumnElementManager","getInstance","Error","SortIndicatorElementManager","initialize","document","body","SortIndicatorModule","this","columnInsertionPoint","getColumnInsertionPoint","columnCount","getColumnCount","initializeSortIndicators","getAllColumns","forEach","column","index","setupColumnSortIndicators","columnIndex","sortIndicatorPlaceholder","querySelector","getSortIndicatorPlaceholderClass","columnName","titleElement","getColumnTitleClass","textContent","trim","registerContainer","source","createColumn","title","createColumnTemplate","addColumns","count","columnHeaders","parseInt","headers","Array","isArray","fragment","createDocumentFragment","addedColumns","i","columnTitle","length","appendChild","push","appendColumns","setColumnCount","createdCells","createCellsForColumn","_dispatchColumnEvent","columns","cells","addColumn","RowElementManager","createCellsForColumns","console","error","removeCellsAtColumnIndex","deleteColumn","removedColumn","warn","removeColumn","removeColumnByTitle","getColumnHeaders","getColumnByIndex","eventName","detail","dispatchEvent","CustomEvent","bubbles","DropdownContainerModule","DropdownManager","SUPPORTED_COLUMNS","instances","Map","_lastSelectedRow","dropdownTypeConfig","row","elements","button","DropdownElementManager","getDropdownButton","valueContainer","getValueContainer","valueText","getValueText","customInput","getCustomInput","setButton","getSetButton","setup","setupRowDropdown","bind","checkboxList","getCheckboxList","checkboxItem","getCheckboxItem","setupColumnDropdown","sort","closeIcon","getCloseIcon","setupSortDropdown","search","searchBar","SearchElementManager","getSearchInput","setupSearchDropdown","column-title","getDropdownButtonColumn","setupColumnTitleDropdown","createDropdown","container","type","typeConfig","content","getDropdownContent","arrow","getArrow","staticInputButtons","getStaticInputButtons","Object","entries","key","getter","dropdown","isOpen","isInEditMode","selectedItem","hasCustomValue","setupToggle","initializeDropdowns","containers","NodeList","getDropdownType","set","getDropdownInstance","get","getInstancesByType","typeInstances","showClass","getClassName","openClass","sortIndicatorsClass","getSortIndicatorsClass","addEventListener","classList","contains","closeDropdown","closeAllDropdowns","DOMUtils","batchUpdate","add","setTimeout","outsideClickHandler","event","target","closest","remove","removeEventListener","setupCloseListener","closeButton","highlightSelectedItem","style","backgroundColor","clearAllHighlights","setButtonText","text","setAttribute","createValueStructure","textElem","arrowClass","buttonText","className","from","childNodes","find","node","nodeType","Node","TEXT_NODE","labelText","innerHTML","createTextNode","disableButton","disabled","enableButton","getLastSelectedRow","getCustomRowCount","rowDropdowns","getCustomInputValue","getSelectedRowCount","customValue","isNaN","setSelectedRowCount","rowCount","toString","matchingOption","btnText","resetCustomInput","value","hasCustomRowCount","setupCustomInput","inputTimer","test","clearTimeout","num","replace","currentPage","PaginationModule","getCurrentPage","TableDataModule","getTotalCount","then","totalCount","enableAllResults","RowManagerModule","setRowCountWithData","setMaxPage","currentRowAmount","startingIndex","newRowAmount","newPage","Math","max","floor","maxPageText","PaginationElementManager","getMaxPage","maxPage","match","validNewPage","min","getPageData","pageData","rowsToSet","remainingRows","Promise","resolve","result","allRows","getAllRows","goToPage","disableAllResults","DataApplierModule","applyDataToRows","catch","getSearchContainer","firstItem","staticInputClass","getRowCount","log","initializeColumnCheckboxes","isIncluded","includes","isDisabled","setupColumnCheckboxHandlers","oldTitle","newTitle","checkboxItemClass","querySelectorAll","item","checkbox","label","checked","checkboxItems","isActive","_pendingColumnOperations","Set","_changeHandler","isChecked","has","preventDefault","opacity","addOperation","getColumnTitleIndex","page","finally","delete","indexOf","deleteOperation","clear","clearPreviousIndicator","id","Date","now","random","activeSortButton","activeSortPlaceholder","activeSortDirection","unregisterContainer","parentNode","removeChild","searchMode","isSearchModeActive","sortMode","isSortModeActive","clearAllSortIndicators","newDirection","sortOptionText","buttonIndex","handleSortIndicatorClick","placeholder","createSortPlaceholder","parentDropdownId","SearchBarModule","updateSearchPlaceholder","getCurrentSearchTerm","clearSearch","columnID","lastColumnAdded","needsRefresh","currentButtonText","availableColumns","staticInputOptions","filter","createCloseButton","btn","classNames","name","option","createElement","currentColumns","currentColumnIndex","existingColumnIndex","clickedElement","dropdownContainer","span","swapColumnTitles","column1","column2","index1","index2","addColumnTitleAtIndex","totalPages","rowsPerPage","pendingNavigations","lastDispatchedPage","abortController","async","updateMaxPages","totalItemCount","await","newTotalPages","ceil","updateMaxPageUI","updateButtonStates","updateCurrentPageUI","setCurrentPageText","setMaxPageText","forceFlag","previousPage","dispatchPageChangeEvent","abort","AbortController","rows","timestamp","requestAnimationFrame","signal","setupEventListeners","buttons","next","getNext","prev","getPrevious","fastForward","getFastForward","fastBack","getFastBackward","e","calculatedTotalPages","undefined","currentRowsPerPage","pages","getTotalPages","getRowsPerPage","getPendingNavigationCount","size","RowManager","PerformanceTracker","start","rowInsertionPoint","getRowInsertionPoint","end","createRow","createRowTemplate","addRows","_validateCount","addedRows","appendRows","_handleRowAddedNotification","removeRows","removedRows","rowsToRemove","removeLastNRows","_dispatchRowEvent","setRowCount","targetCount","getLastNRows","deleteAllRows","clearRowData","clearRowsContent","closeAllExpandedRows","dataset","expanded","collapseExpandedRow","getRowByIndex","itemsRemaining","currentSearchType","searchTimeout","SEARCH_DELAY","performSearch","searchTerm","input","searchType","term","setupInputHandler","isEmpty","isVisible","updateClearButtonVisibility","clearAllSortIndicatorsReset","clearSearchInput","getClearIcon","focus","inputElement","updatePlaceholder","getCurrentSearchType","isSearchActive","refreshElementCache","indicators","activeSort","element","direction","SortIndicatorManager","options","needsEventSetup","createSortIndicatorTemplate","indicatorInfo","setupSortIndicatorEvents","upTriangle","getTriangleUpClass","downTriangle","getTriangleDownClass","registerContainerEvents","parentContainer","indicatorContainer","_sortClickHandler","currentDirection","setTriangleState","dispatchSortEvent","indicatorsToRemove","info","removeIndicator","clearIndicator","getActiveSort","getAllIndicators","state","mode","isBusy","defaultValue","getColumns","updatePagination","fetchData","endpoint","params","queryParams","flatMap","map","c","encodeURIComponent","join","response","fetch","Connection","ok","json","status","getData","config","sortColumn","sortDirection","getRangeData","startIndex","setSearchMode","setSortMode","setRegularMode","deactivateSearch","deactivateSort","handlers","rowsAdded","previousRowCount","data","addedRowCount","pageChanged","itemsOnThisPage","maxValidPage","currentRowCount","needsRowUpdate","columnAdded","searchPerformed","searchCount","rowsToShow","totalResults","searchCleared","sortApplied","sortCleared","sortIndicatorSort","getRangeJobData","handleRowCountChange","rowCountChange","activateSearch","activateSort","getCurrentSortColumn","getCurrentSortDirection","setCurrentPage","TableTitleModule","titleContainer","titleHeading","subtitle","normalCount","initialized","TableTitleManager","sortingInProgress","initializeElements","TableElementManager","getTableTitle","getTableTitleHeading","getOrCreateSubtitle","setInitialTitle","attemptInitialization","existingSubtitle","updateTitleText","updateSubtitleText","updateTitleForSearchState","resultText","updateTitleForSortState","directionText","subtitleText","updateTitleForNormalState","countText","handleSearchData","handleSearchCleared","handleSortData","handleSortCleared","handleSortApplied","handleSortIndicatorSort","handlePageData","refreshTitle","getState"],"mappings":"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","file":"modules.min.js","sourcesContent":["/**\r\n * @title ColumnManagerModule\r\n * @description  Manages the creation and deletion of table columns\r\n * @author Daniel Oliveira\r\n */\r\nconst ColumnManagerModule = (function () {\r\n    let instance = null;\r\n\r\n    class ColumnManager {\r\n        constructor() {\r\n            // Verify dependencies\r\n            if (!ColumnElementManager.getInstance()) {\r\n                throw new Error('ColumnElementManager must be initialized before ColumnManagerModule');\r\n            }\r\n\r\n            // Initialize SortIndicatorModule if needed\r\n            if (!SortIndicatorElementManager.getInstance()) {\r\n                SortIndicatorElementManager.initialize(document.body);\r\n            }\r\n\r\n            if (!SortIndicatorModule.getInstance()) {\r\n                SortIndicatorModule.initialize();\r\n            }\r\n\r\n            // Get column insertion point\r\n            this.columnInsertionPoint = ColumnElementManager.getColumnInsertionPoint();\r\n            if (!this.columnInsertionPoint) {\r\n                throw new Error('Column insertion point not found');\r\n            }\r\n\r\n            // Set column count from cache\r\n            this.columnCount = ColumnElementManager.getColumnCount();\r\n\r\n            // Initialize sort indicators\r\n            this.initializeSortIndicators();\r\n        }\r\n\r\n        // INITIALIZATION METHODS\r\n\r\n        initializeSortIndicators() {\r\n            ColumnElementManager.getAllColumns(true).forEach((column, index) =>\r\n                this.setupColumnSortIndicators(column, index));\r\n        }\r\n\r\n        setupColumnSortIndicators(column, columnIndex) {\r\n            if (!column) return;\r\n\r\n            const sortIndicatorPlaceholder = column.querySelector(`.${ColumnElementManager.getSortIndicatorPlaceholderClass()}`);\r\n            if (!sortIndicatorPlaceholder) return;\r\n\r\n            // Get column title/name\r\n            const titleElement = column.querySelector(`.${ColumnElementManager.getColumnTitleClass()}`);\r\n            const columnName = titleElement ? titleElement.textContent.trim() : '';\r\n\r\n            // Register with SortIndicatorModule with enhanced metadata\r\n            SortIndicatorModule.registerContainer(sortIndicatorPlaceholder, columnIndex, {\r\n                source: 'column',\r\n                columnName: columnName\r\n            });\r\n        }\r\n\r\n        // COLUMN CREATION METHODS\r\n\r\n        createColumn(title) {\r\n            const column = ColumnElementManager.createColumnTemplate(title);\r\n            const columnIndex = this.columnCount; // Get index before we increment it\r\n            this.setupColumnSortIndicators(column, columnIndex);\r\n            return column;\r\n        }\r\n\r\n        addColumns(count, columnHeaders) {\r\n            count = parseInt(count, 10) || 0;\r\n            if (count <= 0) return [];\r\n\r\n            const headers = Array.isArray(columnHeaders) ? columnHeaders : [];\r\n            const fragment = document.createDocumentFragment();\r\n            const addedColumns = [];\r\n\r\n            // Create the columns\r\n            for (let i = 0; i < count; i++) {\r\n                const columnTitle = (i < headers.length) ?\r\n                    headers[i] : `Column ${this.columnCount + i + 1}`;\r\n\r\n                const column = this.createColumn(columnTitle);\r\n                fragment.appendChild(column);\r\n                addedColumns.push(column);\r\n            }\r\n\r\n            // Add the columns to the DOM using the insertion point\r\n            ColumnElementManager.appendColumns(addedColumns, this.columnInsertionPoint);\r\n            this.columnCount += count;\r\n            ColumnElementManager.setColumnCount(this.columnCount);\r\n\r\n            // Create the row-cells for all the columns\r\n            const createdCells = this.createCellsForColumn(count);\r\n\r\n            // Dispatch the event\r\n            this._dispatchColumnEvent('columnsAdded', {\r\n                count,\r\n                columns: addedColumns,\r\n                cells: createdCells\r\n            });\r\n            return addedColumns;\r\n        }\r\n\r\n        addColumn(title) {\r\n            return this.addColumns(1, [title])[0];\r\n        }\r\n\r\n        // CELL MANAGEMENT METHODS\r\n\r\n        createCellsForColumn(columnCount = 1) {\r\n            if (!RowElementManager.getInstance()) {\r\n                console.error('RowElementManager required for createCellsForColumn');\r\n                return [];\r\n            }\r\n\r\n            return RowElementManager.createCellsForColumns(columnCount);\r\n        }\r\n\r\n        removeCellsAtColumnIndex(columnIndex) {\r\n            if (!RowElementManager.getInstance()) {\r\n                console.error('RowElementManager required for removeCellsAtColumnIndex');\r\n                return;\r\n            }\r\n\r\n            RowElementManager.removeCellsAtColumnIndex(columnIndex);\r\n        }\r\n\r\n        // COLUMN DELETION METHOD\r\n\r\n        deleteColumn(index, columnTitle) {\r\n            if (this.columnCount <= 0) return;\r\n\r\n            if (index < 0 || index >= this.columnCount) {\r\n                console.warn('Column index out of bounds');\r\n                return;\r\n            }\r\n\r\n            const columns = ColumnElementManager.getAllColumns(true);\r\n            if (!columns || columns.length <= index) return;\r\n\r\n            // Remove the column\r\n            const removedColumn = columns[index];\r\n\r\n            // Get the sort indicators container\r\n            ColumnElementManager.removeColumn(removedColumn);\r\n            this.removeCellsAtColumnIndex(index);\r\n\r\n            // Update the column count\r\n            this.columnCount--;\r\n            ColumnElementManager.setColumnCount(this.columnCount);\r\n            ColumnElementManager.removeColumnByTitle(columnTitle);\r\n\r\n            this._dispatchColumnEvent('columnDeleted', {});\r\n        }\r\n\r\n        // GETTER METHODS\r\n\r\n        getColumnHeaders() {\r\n            return ColumnElementManager.getColumnHeaders(false);\r\n        }\r\n\r\n        getColumnCount() {\r\n            return this.columnCount;\r\n        }\r\n\r\n        getColumnByIndex(index) {\r\n            return ColumnElementManager.getColumnByIndex(index, true);\r\n        }\r\n\r\n        getAllColumns() {\r\n            return ColumnElementManager.getAllColumns(true);\r\n        }\r\n\r\n        // EVENT HANDLING\r\n\r\n        _dispatchColumnEvent(eventName, detail) {\r\n            this.columnInsertionPoint.dispatchEvent(new CustomEvent(`columnManager:${eventName}`, {\r\n                bubbles: true,\r\n                detail\r\n            }));\r\n        }\r\n    }\r\n\r\n    // Public API \r\n    return {\r\n        initialize() {\r\n            try {\r\n                if (!instance) instance = new ColumnManager();\r\n                return instance;\r\n            } catch (error) {\r\n                console.error('Error initializing ColumnManager:', error);\r\n                throw error;\r\n            }\r\n        },\r\n\r\n        getInstance: () => instance,\r\n\r\n        // Column manipulation methods\r\n        createColumn: title => instance?.createColumn(title) ?? null,\r\n        addColumns: (count, headers) => instance?.addColumns(count, headers) ?? [],\r\n        addColumn: title => instance?.addColumn(title) ?? null,\r\n        deleteColumn: (index, title) => instance?.deleteColumn(index, title),\r\n\r\n        // Getter methods\r\n        getColumnHeaders: () => instance?.getColumnHeaders() ?? [],\r\n        getColumnCount: () => instance?.getColumnCount() ?? 0,\r\n        getColumnByIndex: index => instance?.getColumnByIndex(index) ?? null,\r\n        getAllColumns: () => instance?.getAllColumns() ?? [],\r\n    };\r\n})();","/**\r\n * @title DropdownContainerModule\r\n * @description  Handles animations and interactions for different dropdown types\r\n *               Provides a unified interface for various dropdown behaviors\r\n * @author Daniel Oliveira\r\n */\r\nconst DropdownContainerModule = (function () {\r\n    let instance = null;\r\n\r\n    class DropdownManager {\r\n        static SUPPORTED_COLUMNS = [\r\n            'Name',\r\n            'File Path',\r\n            'Profile Name',\r\n            'Length',\r\n            'Front-cut Off Distance',\r\n            'Square-up Distance'\r\n        ];\r\n\r\n        constructor() {\r\n            this.instances = new Map();\r\n            this._lastSelectedRow = null;\r\n\r\n            // Configuration for dropdown types with element selection and setup method\r\n            this.dropdownTypeConfig = {\r\n                row: {\r\n                    elements: {\r\n                        button: DropdownElementManager.getDropdownButton,\r\n                        valueContainer: DropdownElementManager.getValueContainer,\r\n                        valueText: DropdownElementManager.getValueText,\r\n                        customInput: DropdownElementManager.getCustomInput,\r\n                        setButton: DropdownElementManager.getSetButton\r\n                    },\r\n                    setup: this.setupRowDropdown.bind(this)\r\n                },\r\n                column: {\r\n                    elements: {\r\n                        button: DropdownElementManager.getDropdownButton,\r\n                        checkboxList: DropdownElementManager.getCheckboxList,\r\n                        checkboxItem: DropdownElementManager.getCheckboxItem\r\n                    },\r\n                    setup: this.setupColumnDropdown.bind(this)\r\n                },\r\n                sort: {\r\n                    elements: {\r\n                        button: DropdownElementManager.getDropdownButton,\r\n                        closeIcon: DropdownElementManager.getCloseIcon\r\n                    },\r\n                    setup: this.setupSortDropdown.bind(this)\r\n                },\r\n                search: {\r\n                    elements: {\r\n                        button: DropdownElementManager.getDropdownButton,\r\n                        searchBar: () => SearchElementManager.getSearchInput(false)\r\n                    },\r\n                    setup: this.setupSearchDropdown.bind(this)\r\n                },\r\n                'column-title': {\r\n                    elements: {\r\n                        button: DropdownElementManager.getDropdownButtonColumn\r\n                    },\r\n                    setup: this.setupColumnTitleDropdown.bind(this)\r\n                }\r\n            };\r\n        }\r\n\r\n        // DROPDOWN INITIALIZATION & MANAGEMENT METHODS\r\n\r\n        createDropdown(container, type) {\r\n            if (!container || !type) return null;\r\n\r\n            const typeConfig = this.dropdownTypeConfig[type];\r\n            if (!typeConfig) {\r\n                console.warn(`Unknown dropdown type: ${type}`);\r\n                return null;\r\n            }\r\n\r\n            // Get basic elements common to all dropdowns\r\n            const elements = {\r\n                content: DropdownElementManager.getDropdownContent(container),\r\n                arrow: DropdownElementManager.getArrow(container),\r\n                staticInputButtons: DropdownElementManager.getStaticInputButtons(container)\r\n            }\r\n\r\n            // Add type-specific elements\r\n            Object.entries(typeConfig.elements).forEach(([key, getter]) => {\r\n                elements[key] = getter(container);\r\n            });\r\n\r\n            // Create dropdown state object\r\n            const dropdown = {\r\n                container,\r\n                type,\r\n                elements,\r\n                isOpen: false,\r\n                isInEditMode: true,\r\n                selectedItem: null,\r\n                hasCustomValue: false\r\n            };\r\n\r\n            // Set up behaviors\r\n            this.setupToggle(dropdown);\r\n            typeConfig.setup(dropdown);\r\n\r\n            return dropdown;\r\n        }\r\n\r\n        initializeDropdowns(containers) {\r\n            // Initialize element manager if needed\r\n            !DropdownElementManager.getInstance() && DropdownElementManager.initialize(document.body);\r\n\r\n            // Handle container formats\r\n            const containerArray = Array.isArray(containers) || containers instanceof NodeList\r\n                ? containers\r\n                : [containers];\r\n\r\n            // Create dropdown instances\r\n            containerArray.forEach(container => {\r\n                const type = DropdownElementManager.getDropdownType(container);\r\n                if (!type) return;\r\n\r\n                const dropdown = this.createDropdown(container, type);\r\n                if (dropdown) {\r\n                    this.instances.set(container, dropdown);\r\n                }\r\n            });\r\n        }\r\n\r\n        getDropdownInstance(container) {\r\n            return this.instances.get(container) || null;\r\n        }\r\n\r\n        getInstancesByType(type) {\r\n            if (!type) return [];\r\n\r\n            const typeInstances = [];\r\n            const containers = DropdownElementManager.getInstancesByType(type);\r\n\r\n            containers.forEach(container => {\r\n                const instance = this.instances.get(container);\r\n                instance && typeInstances.push(instance);\r\n            });\r\n\r\n            return typeInstances;\r\n        }\r\n\r\n        // DROPDOWN VISIBILITY CONTROLS\r\n\r\n        setupToggle(dropdown) {\r\n            const { button, content } = dropdown.elements;\r\n            const showClass = DropdownElementManager.getClassName('showClass');\r\n            const openClass = DropdownElementManager.getClassName('openClass');\r\n            const sortIndicatorsClass = SortIndicatorElementManager.getSortIndicatorsClass();\r\n\r\n            button.addEventListener('click', () => {\r\n                const isCurrentlyOpen = content.classList.contains(showClass);\r\n\r\n                if (!isCurrentlyOpen) {\r\n                    // Close other dropdowns first\r\n                    this.closeAllDropdowns();\r\n\r\n                    // Open this dropdown\r\n                    DOMUtils.batchUpdate(() => {\r\n                        content.classList.add(showClass);\r\n                        dropdown.elements.arrow && dropdown.elements.arrow.classList.add(openClass);\r\n                    });\r\n\r\n                    dropdown.isOpen = true;\r\n\r\n                    // Add document click handler for outside clicks\r\n                    setTimeout(() => {\r\n                        document.addEventListener('click', dropdown.outsideClickHandler = (event) => {\r\n                            if (dropdown.type === 'sort' && event.target.closest(`.${sortIndicatorsClass}`)) {\r\n                                return; // Prevent closing if clicking inside a sort indicator\r\n                            }\r\n\r\n                            // Close on clicks outside dropdown\r\n                            if (!button.contains(event.target) && !content.contains(event.target)) {\r\n                                this.closeDropdown(dropdown);\r\n                            }\r\n                        });\r\n                    }, 0);\r\n                } else {\r\n                    this.closeDropdown(dropdown);\r\n                }\r\n            });\r\n        }\r\n\r\n        closeDropdown(dropdown) {\r\n            if (!dropdown.isOpen) return;\r\n\r\n            const { content, arrow } = dropdown.elements;\r\n            const showClass = DropdownElementManager.getClassName('showClass');\r\n            const openClass = DropdownElementManager.getClassName('openClass');\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                content.classList.remove(showClass);\r\n                arrow && arrow.classList.remove(openClass);\r\n            });\r\n\r\n            dropdown.isOpen = false;\r\n            document.removeEventListener('click', dropdown.outsideClickHandler);\r\n        }\r\n\r\n        closeAllDropdowns() {\r\n            this.instances.forEach(dropdown => this.closeDropdown(dropdown));\r\n        }\r\n\r\n        // DROPDOWN SELECTION & HIGHLIGHTING METHODS\r\n\r\n        setupCloseListener(dropdown) {\r\n            const { staticInputButtons } = dropdown.elements;\r\n            if (!staticInputButtons || staticInputButtons.length === 0) return;\r\n\r\n            // Get the first button (header/close button)\r\n            const closeButton = staticInputButtons[0];\r\n            if (!closeButton) return;\r\n\r\n            closeButton.addEventListener('click', () => {\r\n                this.closeDropdown(dropdown);\r\n            });\r\n        }\r\n\r\n        highlightSelectedItem(dropdown, button) {\r\n            // Skip header/close button\r\n            if (!button || button === dropdown.elements.staticInputButtons[0]) {\r\n                return;\r\n            }\r\n\r\n            // Clear previous selection highlight\r\n            if (dropdown.selectedItem && dropdown.selectedItem !== button) {\r\n                dropdown.selectedItem.style.backgroundColor = 'transparent';\r\n            }\r\n\r\n            // Apply highlight to new selection\r\n            button.style.backgroundColor = '#DCDFE4';\r\n            dropdown.selectedItem = button;\r\n            dropdown.hasCustomValue = false;\r\n        }\r\n\r\n        clearAllHighlights(dropdown) {\r\n            const { staticInputButtons } = dropdown.elements;\r\n            if (!staticInputButtons) return;\r\n\r\n            staticInputButtons.forEach(button => {\r\n                button.style.backgroundColor = 'transparent';\r\n            });\r\n\r\n            dropdown.selectedItem = null;\r\n        }\r\n\r\n        setButtonText(dropdown, text) {\r\n            if (!text) return;\r\n\r\n            const { button, valueText } = dropdown.elements;\r\n\r\n            if (valueText) {\r\n                // Update existing text element\r\n                DOMUtils.batchUpdate(() => {\r\n                    valueText.textContent = text;\r\n                    button.setAttribute('title', text);\r\n                });\r\n            } else if (button) {\r\n                // Create structure for displaying value\r\n                this.createValueStructure(dropdown, text);\r\n            }\r\n        }\r\n\r\n        createValueStructure(dropdown, text) {\r\n            const { button } = dropdown.elements;\r\n            const { textElem, arrow } = DropdownElementManager.createValueStructure(button, text);\r\n\r\n            if (textElem && arrow) {\r\n                dropdown.elements.valueText = textElem;\r\n                dropdown.elements.arrow = arrow;\r\n            }\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                const arrowClass = DropdownElementManager.getClassName('arrow');\r\n\r\n                textElem.textContent = text;\r\n                arrow.className = arrowClass;\r\n\r\n                // Save existing label text\r\n                const buttonText = Array.from(button.childNodes)\r\n                    .find(node => node.nodeType === Node.TEXT_NODE && node.textContent.trim());\r\n                const labelText = buttonText ? buttonText.textContent.trim() : '';\r\n\r\n                // Rebuild button\r\n                button.innerHTML = '';\r\n                if (labelText) {\r\n                    button.appendChild(document.createTextNode(labelText));\r\n                }\r\n\r\n                button.appendChild(textElem);\r\n                button.appendChild(arrow);\r\n                button.setAttribute('title', text);\r\n\r\n                // Save references\r\n                dropdown.elements.valueText = textElem;\r\n                dropdown.elements.arrow = arrow;\r\n            });\r\n        }\r\n\r\n        // BUTTON STATE METHODS\r\n\r\n        disableButton(button) {\r\n            DOMUtils.batchUpdate(() => {\r\n                button.disabled = true;\r\n                button.classList.add('disabled');\r\n            });\r\n        }\r\n\r\n        enableButton(button) {\r\n            DOMUtils.batchUpdate(() => {\r\n                button.disabled = false;\r\n                button.classList.remove('disabled');\r\n            });\r\n        }\r\n\r\n        // ROW COUNT METHODS\r\n\r\n        getLastSelectedRow() {\r\n            return this._lastSelectedRow;\r\n        }\r\n\r\n        getCustomRowCount() {\r\n            const rowDropdowns = this.getInstancesByType('row');\r\n            if (!rowDropdowns || rowDropdowns.length === 0) return null;\r\n\r\n            const dropdown = rowDropdowns[0];\r\n            return dropdown.hasCustomValue ? this.getCustomInputValue(dropdown) : null;\r\n        }\r\n\r\n        getSelectedRowCount() {\r\n            const rowDropdowns = this.getInstancesByType('row');\r\n            if (!rowDropdowns || rowDropdowns.length === 0) return 10; // Default\r\n\r\n            const dropdown = rowDropdowns[0];\r\n\r\n            // Check custom value first\r\n            if (dropdown.hasCustomValue) {\r\n                const customValue = this.getCustomInputValue(dropdown);\r\n                if (customValue !== null) return customValue;\r\n            }\r\n\r\n            // Try value from display text\r\n            if (dropdown.elements.valueText) {\r\n                const text = dropdown.elements.valueText.textContent.trim();\r\n                const count = parseInt(text, 10);\r\n                return !isNaN(count) ? count : 10;\r\n            }\r\n\r\n            // Try value from selected item\r\n            if (dropdown.selectedItem) {\r\n                const text = dropdown.selectedItem.textContent.trim();\r\n                const count = parseInt(text, 10);\r\n                return !isNaN(count) ? count : 10;\r\n            }\r\n\r\n            return 10; // Default\r\n        }\r\n\r\n        setSelectedRowCount(rowCount) {\r\n            rowCount = parseInt(rowCount, 10);\r\n            if (isNaN(rowCount) || rowCount < 0) {\r\n                console.warn('Invalid row count provided:', rowCount);\r\n                return false;\r\n            }\r\n\r\n            const rowDropdowns = this.getInstancesByType('row');\r\n            if (!rowDropdowns || rowDropdowns.length === 0) {\r\n                console.warn('No row dropdown found to update');\r\n                return false;\r\n            }\r\n\r\n            const dropdown = rowDropdowns[0];\r\n            const { elements } = dropdown;\r\n            const { staticInputButtons, customInput, setButton } = elements;\r\n\r\n            // Update button text\r\n            this.setButtonText(dropdown, rowCount.toString());\r\n\r\n            // Check if count matches a predefined option\r\n            let matchingOption = null;\r\n            if (staticInputButtons && staticInputButtons.length > 1) {\r\n                for (let i = 1; i < staticInputButtons.length; i++) {\r\n                    const btnText = staticInputButtons[i].textContent.trim();\r\n                    const btnValue = parseInt(btnText, 10);\r\n                    if (btnValue === rowCount) {\r\n                        matchingOption = staticInputButtons[i];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If we found a matching preset option\r\n            if (matchingOption) {\r\n                if (dropdown.hasCustomValue) {\r\n                    dropdown.hasCustomValue = false;\r\n                    this.resetCustomInput(dropdown);\r\n                }\r\n                this.highlightSelectedItem(dropdown, matchingOption);\r\n            }\r\n            // Otherwise, set as custom value\r\n            else if (customInput && setButton) {\r\n                this.clearAllHighlights(dropdown);\r\n                customInput.value = rowCount.toString();\r\n                setButton.textContent = \"Edit\";\r\n                customInput.disabled = true;\r\n                dropdown.isInEditMode = false;\r\n                dropdown.hasCustomValue = true;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        hasCustomRowCount() {\r\n            const rowDropdowns = this.getInstancesByType('row');\r\n            return rowDropdowns && rowDropdowns.length > 0 ?\r\n                rowDropdowns[0].hasCustomValue === true : false;\r\n        }\r\n\r\n        // CUSTOM INPUT HANDLING METHODS\r\n\r\n        getCustomInputValue(dropdown) {\r\n            if (!dropdown.hasCustomValue) return null;\r\n\r\n            const { valueText } = dropdown.elements;\r\n            if (valueText) {\r\n                const text = valueText.textContent.trim();\r\n                const count = parseInt(text, 10);\r\n                return !isNaN(count) ? count : null;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        setupCustomInput(dropdown) {\r\n            const { customInput, setButton } = dropdown.elements;\r\n            if (!customInput || !setButton) return;\r\n\r\n            // Initial setup\r\n            setButton.textContent = \"Set\";\r\n\r\n            // Handle input validation with debounce\r\n            let inputTimer;\r\n            customInput.addEventListener('input', (event) => {\r\n                // Allow only digits\r\n                const value = event.target.value;\r\n                if (value !== '' && !/^\\d*$/.test(value)) {\r\n                    customInput.value = value.replace(/\\D/g, '');\r\n                    return;\r\n                }\r\n\r\n                // Debounce constraint checking\r\n                clearTimeout(inputTimer);\r\n                inputTimer = setTimeout(() => {\r\n                    if (value !== '') {\r\n                        const num = parseInt(value, 10);\r\n                        if (num < 5) {\r\n                            customInput.value = '5';  // Minimum value\r\n                        } else if (num > 35) {\r\n                            customInput.value = '35'; // Maximum value\r\n                        }\r\n                    }\r\n                }, 300);\r\n            });\r\n\r\n            // Validate on focus loss\r\n            customInput.addEventListener('blur', () => {\r\n                if (customInput.value.trim() !== '') {\r\n                    let value = parseInt(customInput.value, 10);\r\n                    if (isNaN(value) || value < 5) {\r\n                        value = 5;  // Minimum value\r\n                    } else if (value > 35) {\r\n                        value = 35; // Maximum value\r\n                    }\r\n                    customInput.value = value;\r\n                }\r\n            });\r\n\r\n            // Initialize in edit mode\r\n            dropdown.isInEditMode = true;\r\n            setButton.textContent = \"Set\";\r\n            customInput.disabled = false;\r\n\r\n            // Handle Set/Edit button\r\n            setButton.addEventListener('click', () => {\r\n                if (dropdown.isInEditMode) {\r\n                    // In Edit mode, apply value\r\n                    const value = customInput.value.trim();\r\n                    const num = parseInt(value, 10);\r\n\r\n                    if (value && num >= 5 && num <= 35) {\r\n                        // Clear existing static selection\r\n                        this.clearAllHighlights(dropdown);\r\n\r\n                        // Switch to view mode\r\n                        setButton.textContent = \"Edit\";\r\n                        customInput.disabled = true;\r\n                        dropdown.isInEditMode = false;\r\n                        dropdown.hasCustomValue = true;\r\n                        const currentPage = PaginationModule.getCurrentPage();\r\n\r\n                        // Notify about row count change\r\n                        document.dispatchEvent(new CustomEvent('dropdown:rowCountChanged', {\r\n                            bubbles: true,\r\n                            detail: {\r\n                                rowCount: num,\r\n                                source: 'customInput'\r\n                            }\r\n                        }));\r\n\r\n                        // Wait for event processing to complete\r\n                        setTimeout(() => {\r\n                            // Get total count and current page\r\n                            TableDataModule.getTotalCount().then((totalCount) => {\r\n                                if (num >= totalCount) {\r\n                                    // Handle case when row count exceeds total items\r\n                                    DropdownContainerModule.setSelectedRowCount(totalCount);\r\n                                    DropdownContainerModule.enableAllResults(totalCount);\r\n                                    RowManagerModule.setRowCountWithData(totalCount, false);\r\n                                    PaginationModule.setMaxPage(1);\r\n                                } else {\r\n                                    // Calculate pagination parameters\r\n                                    const currentRowAmount = DropdownContainerModule.getSelectedRowCount();\r\n                                    const startingIndex = (currentPage - 1) * currentRowAmount;\r\n\r\n                                    // Calculate new page based on starting index\r\n                                    const newRowAmount = num;\r\n                                    const newPage = Math.max(1, Math.floor(startingIndex / newRowAmount) + 1);\r\n\r\n                                    // Get max page\r\n                                    const maxPageText = PaginationElementManager.getMaxPage().textContent;\r\n                                    const maxPage = parseInt(maxPageText.match(/\\d+/)[0], 10);\r\n\r\n                                    // Ensure new page is valid\r\n                                    const validNewPage = Math.min(newPage, maxPage);\r\n\r\n                                    // Fetch data for the new configuration\r\n                                    const columns = ColumnElementManager.getColumnHeaders();\r\n                                    if (columns && columns.length) {\r\n                                        TableDataModule.getPageData(validNewPage, newRowAmount, columns)\r\n                                            .then(pageData => {\r\n                                                // Handle row count setting based on page\r\n                                                let rowsToSet = newRowAmount;\r\n                                                if (validNewPage === maxPage) {\r\n                                                    // For last page, calculate remaining rows\r\n                                                    const remainingRows = totalCount - ((maxPage - 1) * newRowAmount);\r\n                                                    rowsToSet = remainingRows;\r\n                                                }\r\n\r\n                                                // Create a Promise that resolves when row update is complete\r\n                                                const rowUpdatePromise = new Promise(resolve => {\r\n                                                    // Call setRowCountWithData with false flag\r\n                                                    const result = RowManagerModule.setRowCountWithData(rowsToSet, false);\r\n                                                    if (result instanceof Promise) {\r\n                                                        result.then(resolve);\r\n                                                    } else {\r\n                                                        resolve();\r\n                                                    }\r\n                                                });\r\n\r\n                                                // Apply data after row count is updated\r\n                                                rowUpdatePromise.then(() => {\r\n                                                    // Get rows AFTER the row count has been set\r\n                                                    const allRows = RowElementManager.getAllRows();\r\n\r\n                                                    // Update pagination and UI\r\n                                                    PaginationModule.goToPage(validNewPage);\r\n                                                    DropdownContainerModule.disableAllResults();\r\n                                                    DropdownContainerModule.setSelectedRowCount(num);\r\n\r\n                                                    // Apply data to rows\r\n                                                    DataApplierModule.applyDataToRows(allRows, pageData, columns);\r\n                                                    this.setButtonText(dropdown, value);\r\n                                                    this._lastSelectedRow = value;\r\n                                                });\r\n                                            })\r\n                                            .catch(error => {\r\n                                                console.error(\"Error fetching page data after custom row count change:\", error);\r\n                                            });\r\n                                    }\r\n                                }\r\n                            }).catch((error) => {\r\n                                console.error(\"Error fetching total count:\", error);\r\n                            });\r\n                        }, 50); // Small delay to ensure event processing completes\r\n                    }\r\n                } else {\r\n                    // In View mode, switch to Edit mode\r\n                    setButton.textContent = \"Set\";\r\n                    customInput.disabled = false;\r\n                    dropdown.isInEditMode = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        resetCustomInput(dropdown) {\r\n            const { customInput, setButton } = dropdown.elements;\r\n            if (!customInput || !setButton) return;\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                setButton.textContent = \"Set\";\r\n                customInput.disabled = false;\r\n                customInput.value = '';\r\n            });\r\n\r\n            dropdown.isInEditMode = true;\r\n            dropdown.hasCustomValue = false;\r\n        }\r\n\r\n        // RESULTS DISPLAY METHODS\r\n\r\n        enableAllResults(key) {\r\n            const searchText = SearchElementManager.getSearchContainer();\r\n            searchText.textContent = `Showing ${key} ${key === 1 ? 'item' : 'items'}`;\r\n        }\r\n\r\n        disableAllResults() {\r\n            const searchText = SearchElementManager.getSearchContainer();\r\n            searchText.textContent = '';\r\n            DropdownContainerModule.setSelectedRowCount(this._lastSelectedRow);\r\n        }\r\n\r\n        // DROPDOWN TYPE-SPECIFIC SETUP METHODS\r\n\r\n        setupRowDropdown(dropdown) {\r\n            const { elements } = dropdown;\r\n            const { staticInputButtons, content } = elements;\r\n\r\n            // Setup close listener\r\n            this.setupCloseListener(dropdown);\r\n\r\n            // Set default selection to first option\r\n            const firstItem = staticInputButtons[1];\r\n            if (firstItem && elements.valueText) {\r\n                this.setButtonText(dropdown, firstItem.textContent.trim());\r\n                this._lastSelectedRow = firstItem.textContent.trim();\r\n                this.highlightSelectedItem(dropdown, firstItem);\r\n            }\r\n\r\n            // Set up handler for static input buttons\r\n            const staticInputClass = DropdownElementManager.getClassName('staticInput');\r\n\r\n            // Use event delegation\r\n            content.addEventListener('click', (event) => {\r\n                const button = event.target.closest(`.${staticInputClass}`);\r\n                if (!button) return;\r\n\r\n                // Skip the first button (header/close)\r\n                if (button === staticInputButtons[0]) return;\r\n\r\n                const text = button.textContent.trim();\r\n                if (!text) return;\r\n\r\n           \r\n                if (parseInt(text, 10) === RowElementManager.getRowCount()) {\r\n                    return;\r\n                }\r\n                // Reset custom input if active\r\n                if (dropdown.hasCustomValue) {\r\n                    dropdown.hasCustomValue = false;\r\n                    this.resetCustomInput(dropdown);\r\n                }\r\n\r\n                // Highlight selected item\r\n                this.highlightSelectedItem(dropdown, button);\r\n\r\n                this._lastSelectedRow = text;\r\n\r\n                // Apply selection to table rows\r\n                TableDataModule.getTotalCount().then((totalCount) => {\r\n                    const currentPage = PaginationModule.getCurrentPage();\r\n                    if (text > totalCount) {\r\n                        DropdownContainerModule.setSelectedRowCount(totalCount);\r\n                        DropdownContainerModule.enableAllResults(totalCount);\r\n                        RowManagerModule.setRowCountWithData(totalCount, currentPage);\r\n                        PaginationModule.setMaxPage(1);\r\n                    }\r\n                    else {\r\n                        const rowCount = parseInt(text, 10);\r\n                        if (!isNaN(rowCount)) {\r\n                            document.dispatchEvent(new CustomEvent('dropdown:rowCountChanged', {\r\n                                bubbles: true,\r\n                                detail: { rowCount: rowCount, source: 'staticInput' }\r\n                            }));\r\n\r\n                            // Process in next event loop\r\n                            setTimeout(() => {\r\n                                const maxPageText = PaginationElementManager.getMaxPage().textContent;\r\n                                const maxPage = parseInt(maxPageText.match(/\\d+/)[0], 10);\r\n\r\n                                const currentRowAmount = DropdownContainerModule.getSelectedRowCount();\r\n                                const startingIndex = (currentPage - 1) * currentRowAmount;\r\n\r\n                                // Calculate new page based on new row count\r\n                                const newRowAmount = parseInt(text, 10);\r\n                                const newPage = Math.max(1, Math.floor(startingIndex / newRowAmount) + 1);\r\n\r\n                                // Validate new page doesn't exceed max page\r\n                                const validNewPage = Math.min(newPage, maxPage);\r\n\r\n                                // Get data for the new page configuration\r\n                                const columns = ColumnElementManager.getColumnHeaders();\r\n                                if (columns && columns.length) {\r\n                                    TableDataModule.getPageData(validNewPage, newRowAmount, columns)\r\n                                        .then(pageData => {\r\n                                            let remainingRows = null;\r\n                                            if (validNewPage === maxPage) {\r\n                                                remainingRows = totalCount - ((maxPage - 1) * newRowAmount);\r\n                                                RowManagerModule.setRowCountWithData(remainingRows, validNewPage);\r\n                                            }\r\n                                            else {\r\n                                                console.log(\"setting here! with\", text);\r\n                                                RowManagerModule.setRowCountWithData(text, validNewPage);\r\n                                            }\r\n\r\n                                            const allRows = RowElementManager.getAllRows();\r\n                                            PaginationModule.goToPage(validNewPage);\r\n                                            DropdownContainerModule.disableAllResults();\r\n                                            DataApplierModule.applyDataToRows(allRows, pageData, columns);\r\n                                        })\r\n                                        .catch(error => {\r\n                                            console.error(\"Error fetching page data after row count change:\", error);\r\n                                        });\r\n                                }\r\n                            }, 50);\r\n                        }\r\n                    }\r\n                }).catch((error) => {\r\n                    console.error(\"Error fetching total count:\", error);\r\n                });\r\n            });\r\n\r\n            document.addEventListener('search:cleared', function (event) {\r\n                this.disableAllResults();\r\n            }.bind(this));\r\n\r\n            // Set up custom input\r\n            this.setupCustomInput(dropdown);\r\n        }\r\n\r\n        setupColumnDropdown(dropdown) {\r\n            const { elements } = dropdown;\r\n            const { staticInputButtons, content } = elements;\r\n\r\n            // Setup close listener\r\n            this.setupCloseListener(dropdown);\r\n\r\n            // Track column move mode state\r\n            let isInMoveMode = false;\r\n\r\n            // Initialize checkboxes based on current columns\r\n            this.initializeColumnCheckboxes(dropdown);\r\n\r\n            // Update button states based on current columns\r\n            if (staticInputButtons && staticInputButtons.length) {\r\n                const headers = ColumnManagerModule.getColumnHeaders();\r\n\r\n                staticInputButtons.forEach(button => {\r\n                    const value = button.textContent.trim();\r\n                    const isIncluded = headers.includes(value);\r\n                    const isDisabled = button.classList.contains('disabled');\r\n\r\n                    if (isIncluded && !isDisabled) {\r\n                        this.disableButton(button);\r\n                    } else if (!isIncluded && isDisabled) {\r\n                        this.enableButton(button);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Set up checkbox handlers\r\n            this.setupColumnCheckboxHandlers(dropdown);\r\n\r\n            document.addEventListener('columnTitle:changed', (event) => {\r\n                const { oldTitle, newTitle } = event.detail;\r\n\r\n                // Find checkbox items\r\n                const checkboxItemClass = DropdownElementManager.getClassName('checkboxItem');\r\n                const checkboxList = dropdown.elements.checkboxList;\r\n                if (!checkboxList) return;\r\n\r\n                const checkboxItems = checkboxList.querySelectorAll(`.${checkboxItemClass}`);\r\n\r\n                // Update all checkboxes - uncheck the old title's checkbox\r\n                checkboxItems.forEach(item => {\r\n                    const checkbox = item.querySelector('input[type=\"checkbox\"]');\r\n                    const label = item.querySelector('label');\r\n\r\n                    if (!checkbox || !label) return;\r\n\r\n                    const labelText = label.textContent.trim();\r\n\r\n                    // If label matches the old title, uncheck it\r\n                    if (labelText === oldTitle) {\r\n                        checkbox.checked = false;\r\n                    }\r\n\r\n                    // If label matches the new title, make sure it's checked\r\n                    if (labelText === newTitle) {\r\n                        checkbox.checked = true;\r\n                    }\r\n                });\r\n            });\r\n\r\n            \r\n\r\n            // Set up handler for static input buttons\r\n            const staticInputClass = DropdownElementManager.getClassName('staticInput');\r\n\r\n            // Use event delegation\r\n            content.addEventListener('click', (event) => {\r\n                const button = event.target.closest(`.${staticInputClass}`);\r\n                if (!button) return;\r\n\r\n                // Skip the first button (header/close)\r\n                if (button === staticInputButtons[0]) return;\r\n\r\n                const text = button.textContent.trim();\r\n                if (!text) return;\r\n\r\n               \r\n            });\r\n        }\r\n\r\n        initializeColumnCheckboxes(dropdown) {\r\n            const { checkboxList } = dropdown.elements;\r\n            if (!checkboxList) return;\r\n\r\n            // Get current column headers\r\n            const headers = ColumnManagerModule.getColumnHeaders();\r\n\r\n            // Find checkbox items\r\n            const checkboxItemClass = DropdownElementManager.getClassName('checkboxItem');\r\n            const checkboxItems = checkboxList.querySelectorAll(`.${checkboxItemClass}`);\r\n\r\n            if (!checkboxItems || checkboxItems.length === 0) return;\r\n\r\n            // Update checkboxes to match column state\r\n            checkboxItems.forEach(item => {\r\n                const checkbox = item.querySelector('input[type=\"checkbox\"]');\r\n                const label = item.querySelector('label');\r\n\r\n                if (!checkbox || !label) return;\r\n\r\n                const labelText = label.textContent.trim();\r\n                const isActive = headers.includes(labelText);\r\n\r\n                if (checkbox.checked !== isActive) {\r\n                    checkbox.checked = isActive;\r\n                }\r\n            });\r\n        }\r\n\r\n        setupColumnCheckboxHandlers(dropdown) {\r\n            const { checkboxList } = dropdown.elements;\r\n            if (!checkboxList) return;\r\n\r\n            // Find checkbox items\r\n            const checkboxItemClass = DropdownElementManager.getClassName('checkboxItem');\r\n            const checkboxItems = checkboxList.querySelectorAll(`.${checkboxItemClass}`);\r\n\r\n            if (!checkboxItems || checkboxItems.length === 0) return;\r\n\r\n            // Track operations in progress to prevent overlapping\r\n            if (!dropdown._pendingColumnOperations) {\r\n                dropdown._pendingColumnOperations = new Set();\r\n            }\r\n\r\n            // Clear existing delegated handler to prevent duplication\r\n            if (checkboxList._changeHandler) {\r\n                checkboxList.removeEventListener('change', checkboxList._changeHandler);\r\n            }\r\n\r\n            // Use a single delegated event handler with queue management\r\n            checkboxList._changeHandler = function (event) {\r\n                // Only process checkbox changes\r\n                if (event.target.type !== 'checkbox') return;\r\n\r\n                const item = event.target.closest(`.${checkboxItemClass}`);\r\n                if (!item) return;\r\n\r\n                const checkbox = event.target;\r\n                const label = item.querySelector('label');\r\n                if (!label) return;\r\n\r\n                const labelText = label.textContent.trim();\r\n                const isChecked = checkbox.checked;\r\n\r\n                // If operation for this column is already in progress, prevent rapid clicking\r\n                if (dropdown._pendingColumnOperations.has(labelText)) {\r\n                    // Revert the checkbox state to previous state\r\n                    event.preventDefault();\r\n                    checkbox.checked = !isChecked;\r\n                    return;\r\n                }\r\n\r\n                // Add to pending operations\r\n                dropdown._pendingColumnOperations.add(labelText);\r\n\r\n                // Visual feedback that operation is in progress\r\n                checkbox.disabled = true;\r\n                item.style.opacity = '0.7';\r\n\r\n                if (!isChecked) {\r\n                    // Ensure at least three columns remains visible\r\n                    const headers = ColumnManagerModule.getColumnHeaders();\r\n                    if (headers.length <= 3 && headers.includes(labelText)) {\r\n                        // Revert checkbox state\r\n                        setTimeout(() => {\r\n                            checkbox.checked = true;\r\n                            checkbox.disabled = false;\r\n                            item.style.opacity = '1';\r\n                            dropdown._pendingColumnOperations.delete(labelText);\r\n                        }, 0);\r\n                        console.warn(\"At least three columns must remain visible\");\r\n                        return;\r\n                    }\r\n\r\n                    // Remove column with completion handling\r\n                    const columnIndex = headers.indexOf(labelText);\r\n                    if (columnIndex !== -1) {\r\n                        const deleteOperation = ColumnManagerModule.deleteColumn(columnIndex, labelText);\r\n\r\n                        // Handle both Promise and non-Promise returns\r\n                        if (deleteOperation instanceof Promise) {\r\n                            deleteOperation.finally(() => {\r\n                                // Re-enable checkbox after operation completes\r\n                                checkbox.disabled = false;\r\n                                item.style.opacity = '1';\r\n                                dropdown._pendingColumnOperations.delete(labelText);\r\n                            });\r\n                        } else {\r\n                            // If not a Promise, re-enable after a short delay\r\n                            setTimeout(() => {\r\n                                checkbox.disabled = false;\r\n                                item.style.opacity = '1';\r\n                                dropdown._pendingColumnOperations.delete(labelText);\r\n                            }, 300);\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Add column with completion handling\r\n                    const addOperation = ColumnManagerModule.addColumns(1, [labelText]);\r\n                    const columnIndex = ColumnElementManager.getColumnTitleIndex(labelText);\r\n\r\n                    // Notify about column addition\r\n                    document.dispatchEvent(new CustomEvent('columnManager:columnAdded', {\r\n                        bubbles: true,\r\n                        detail: {\r\n                            column: labelText,\r\n                            columnIndex,\r\n                            page: PaginationModule.getCurrentPage(),\r\n                            rowCount: RowManagerModule.getRowCount()\r\n                        }\r\n                    }));\r\n\r\n                    // Handle both Promise and non-Promise returns\r\n                    if (addOperation instanceof Promise) {\r\n                        addOperation.finally(() => {\r\n                            // Re-enable checkbox after operation completes\r\n                            checkbox.disabled = false;\r\n                            item.style.opacity = '1';\r\n                            dropdown._pendingColumnOperations.delete(labelText);\r\n                        });\r\n                    } else {\r\n                        // If not a Promise, re-enable after a short delay\r\n                        setTimeout(() => {\r\n                            checkbox.disabled = false;\r\n                            item.style.opacity = '1';\r\n                            dropdown._pendingColumnOperations.delete(labelText);\r\n                        }, 300);\r\n                    }\r\n                }\r\n            };\r\n\r\n            // Add the delegated handler to the parent element\r\n            checkboxList.addEventListener('change', checkboxList._changeHandler);\r\n\r\n            // Clear pending operations when dropdown closes\r\n            document.addEventListener('click', (event) => {\r\n                if (!checkboxList.contains(event.target) &&\r\n                    !dropdown.elements.button.contains(event.target) &&\r\n                    dropdown.isOpen) {\r\n                    dropdown._pendingColumnOperations.clear();\r\n                }\r\n            });\r\n        }\r\n\r\n        setupSortDropdown(dropdown) {\r\n            const { elements } = dropdown;\r\n            const { staticInputButtons, content } = dropdown.elements;\r\n            const staticInputClass = DropdownElementManager.getClassName('staticInput');\r\n\r\n            this.setupCloseListener(dropdown);\r\n\r\n            // Generate a unique identifier for this dropdown instance\r\n            dropdown.id = `dropdown-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\r\n\r\n            // Track the currently active sort option\r\n            dropdown.activeSortButton = null;\r\n            dropdown.activeSortPlaceholder = null;\r\n            dropdown.activeSortDirection = null;\r\n\r\n            // Initialize SortIndicatorModule if needed\r\n            if (!SortIndicatorElementManager.getInstance()) {\r\n                SortIndicatorElementManager.initialize(document.body);\r\n            }\r\n\r\n            if (!SortIndicatorModule.getInstance()) {\r\n                SortIndicatorModule.initialize();\r\n            }\r\n\r\n            // Function to clear the previous sort indicator\r\n            const clearPreviousIndicator = () => {\r\n                if (dropdown.activeSortPlaceholder) {\r\n                    // Unregister from central module\r\n                    SortIndicatorModule.unregisterContainer(dropdown.activeSortPlaceholder);\r\n\r\n                    // Remove from DOM\r\n                    if (dropdown.activeSortPlaceholder.parentNode) {\r\n                        dropdown.activeSortPlaceholder.parentNode.removeChild(dropdown.activeSortPlaceholder);\r\n                    }\r\n\r\n                    dropdown.activeSortPlaceholder = null;\r\n                    dropdown.activeSortButton = null;\r\n                    dropdown.activeSortDirection = null;\r\n                }\r\n            };\r\n\r\n            // Use event delegation for handling clicks on sort options\r\n            content.addEventListener('click', (event) => {\r\n                const button = event.target.closest(`.${staticInputClass}`);\r\n                const searchMode = TableDataModule.isSearchModeActive();\r\n                const sortMode = TableDataModule.isSortModeActive();\r\n                if (!button) return;\r\n\r\n                // Check if this is the first button (header/close)\r\n                if (button === staticInputButtons[0]) {\r\n                    this.closeDropdown(dropdown);\r\n                    return;\r\n                }\r\n\r\n                // Check if this is the second button (clear all indicators)\r\n                if (button === staticInputButtons[1]) {\r\n                    // Direct call to the global module for clearing all indicators\r\n                    if (searchMode || !sortMode)  return;\r\n                    SortIndicatorModule.clearAllSortIndicators();\r\n\r\n                    // Also clear our local reference\r\n                    clearPreviousIndicator();\r\n                    return;\r\n                }\r\n\r\n                // Get the text for this sort option\r\n                const sortOptionText = button.textContent.trim();\r\n\r\n                // Get column index based on button position (skip header button)\r\n                const buttonIndex = Array.from(staticInputButtons).indexOf(button) - 1;\r\n\r\n                // Check if clicking the same button (toggle case)\r\n                const isSameButton = (button === dropdown.activeSortButton);\r\n\r\n                if (isSameButton) {\r\n                    // Toggle direction for same button\r\n                    const newDirection = dropdown.activeSortDirection === 'up' ? 'down' : 'up';\r\n                    dropdown.activeSortDirection = newDirection;\r\n\r\n                    // Apply new direction\r\n                    SortIndicatorModule.handleSortIndicatorClick(dropdown.activeSortPlaceholder, newDirection);\r\n                    return;\r\n                }\r\n\r\n                // This is a new button selection\r\n\r\n                // Clear previous indicator (if any)\r\n                clearPreviousIndicator();\r\n\r\n                // Create a new placeholder for the sort indicator\r\n                const placeholder = SortIndicatorElementManager.createSortPlaceholder();\r\n                placeholder.className = 'sort-indicator-placeholder';\r\n\r\n                // Add the placeholder to the button\r\n                DOMUtils.batchUpdate(() => {\r\n                    button.appendChild(placeholder);\r\n                });\r\n\r\n                // Track the currently active elements\r\n                dropdown.activeSortButton = button;\r\n                dropdown.activeSortPlaceholder = placeholder;\r\n                dropdown.activeSortDirection = 'up'; // Default to 'up' for first selection\r\n\r\n                // Register with SortIndicatorModule with enhanced metadata\r\n                SortIndicatorModule.registerContainer(placeholder, buttonIndex, {\r\n                    source: 'dropdown',\r\n                    columnName: sortOptionText,\r\n                    parentDropdownId: dropdown.id\r\n                });\r\n\r\n                // Apply initial direction\r\n                SortIndicatorModule.handleSortIndicatorClick(placeholder, 'up');\r\n            });\r\n\r\n            // Add listener for sort events from other sources\r\n            document.addEventListener('sortIndicator:sort', (event) => {\r\n                const { source, parentDropdownId } = event.detail;\r\n\r\n                // Only respond if the dropdown is open\r\n                if (!dropdown.isOpen) return;\r\n\r\n                // If sort came from a column, clear indicators and close dropdown\r\n                if (source === 'column') {\r\n                    clearPreviousIndicator();\r\n                    this.closeDropdown(dropdown);\r\n                }\r\n            });\r\n        }\r\n\r\n        setupSearchDropdown(dropdown) {\r\n            const { elements } = dropdown;\r\n            const { staticInputButtons, content, searchBar } = elements;\r\n\r\n            // Setup close listener\r\n            this.setupCloseListener(dropdown);\r\n\r\n            // Set initial selection\r\n            if (staticInputButtons && staticInputButtons.length > 1) {\r\n                // Select first option after header\r\n                this.highlightSelectedItem(dropdown, staticInputButtons[1]);\r\n                if (searchBar) SearchBarModule.updateSearchPlaceholder(searchBar, staticInputButtons[1].textContent);\r\n            }\r\n\r\n            // Set up handlers for search type selection\r\n            const staticInputClass = DropdownElementManager.getClassName('staticInput');\r\n\r\n            // Use event delegation\r\n            content.addEventListener('click', (event) => {\r\n                const button = event.target.closest(`.${staticInputClass}`);\r\n                if (!button) return;\r\n\r\n                // Skip the first button (header/close)\r\n                if (button === staticInputButtons[0]) return;\r\n\r\n                const text = button.textContent.trim();\r\n                if (!text) return;\r\n\r\n                // Highlight selected item\r\n                this.highlightSelectedItem(dropdown, button);\r\n\r\n                // Update search placeholder\r\n                if (searchBar) SearchBarModule.updateSearchPlaceholder(searchBar, text);\r\n\r\n                // Clear search if active\r\n                if (SearchBarModule.getCurrentSearchTerm() !== '') {\r\n                    SearchBarModule.clearSearch();\r\n                }\r\n            });\r\n        }\r\n\r\n        setupColumnTitleDropdown(dropdown) {\r\n            const { SUPPORTED_COLUMNS } = this.constructor;\r\n            this.setupCloseListener(dropdown);\r\n\r\n            const columnID = dropdown.elements.button.id;\r\n            const columnText = columnID;\r\n            this.setButtonText(dropdown, columnText);\r\n\r\n            // Track column changes with detail\r\n            ColumnElementManager.getColumnInsertionPoint().addEventListener(\r\n                'columnManager:columnsAdded',\r\n                (event) => {\r\n                    dropdown.lastColumnAdded = event.detail?.column || null;\r\n                    dropdown.needsRefresh = true;\r\n                }\r\n            );\r\n\r\n            // Open handler with optimized refresh\r\n            dropdown.elements.button.addEventListener('click', () => {\r\n                const { content, staticInputButtons } = dropdown.elements;\r\n\r\n                // Get current columns and button text\r\n                dropdown.availableColumns = ColumnElementManager.getColumnHeaders(true);\r\n                const currentButtonText = dropdown.elements.button.querySelector('span').textContent;\r\n\r\n                // Calculate options - show all SUPPORTED_COLUMNS except the current button text\r\n                dropdown.staticInputOptions = SUPPORTED_COLUMNS.filter(column => column !== currentButtonText);\r\n\r\n                content.innerHTML = '';\r\n\r\n                // Add close button as first element\r\n                const closeButton = DropdownElementManager.createCloseButton(\"Change To\");\r\n               \r\n                content.appendChild(closeButton);\r\n\r\n                // Add existing buttons and new options\r\n                if (staticInputButtons) {\r\n                    const filteredButtons = staticInputButtons.filter(btn =>\r\n                        !btn.classList.contains(DropdownElementManager.getClassName('closeButton')) &&\r\n                        !btn.classList.contains(DropdownElementManager.getClassName('titleElement'))\r\n                    );\r\n                    filteredButtons.forEach(btn => content.appendChild(btn));\r\n                }\r\n\r\n                const classNames = [\r\n                    DropdownElementManager.getClassName('staticInput'),\r\n                    DropdownElementManager.getClassName('dropdownItem'),\r\n                ];\r\n\r\n                dropdown.staticInputOptions.forEach(name => {\r\n                    const option = document.createElement('div');\r\n                    option.classList.add(...classNames);\r\n                    option.textContent = name;\r\n                    content.appendChild(option);\r\n                });\r\n\r\n                dropdown.needsRefresh = false;\r\n            });\r\n\r\n            const staticInputClass = DropdownElementManager.getClassName('staticInput');\r\n            dropdown.elements.content.addEventListener('click', event => {\r\n                const clickedElement = event.target.closest(`.${staticInputClass}`);\r\n                if (clickedElement) {\r\n                    // If close button was clicked, close dropdown without additional action\r\n                    if (clickedElement.classList.contains(DropdownElementManager.getClassName('closeButton'))) {\r\n                        this.closeDropdown(dropdown);\r\n                        return;\r\n                    }\r\n\r\n                    const newTitle = clickedElement.textContent;\r\n                    const currentButtonText = dropdown.elements.button.querySelector('span').textContent;\r\n                    const currentColumns = ColumnElementManager.getColumnHeaders();\r\n\r\n                    const currentColumnIndex = currentColumns.indexOf(currentButtonText);\r\n\r\n                    // Check if the selected option is already displayed (case for column swap)\r\n                    const existingColumnIndex = currentColumns.indexOf(newTitle);\r\n\r\n                    if (existingColumnIndex !== -1) {\r\n                        // CASE 1: Column Swap - the selected column is already displayed\r\n\r\n                        // 1. Update the UI for this dropdown\r\n                        this.setButtonText(dropdown, newTitle);\r\n                        dropdown.elements.button.id = newTitle;\r\n\r\n                        // 2. Find and update the other column's dropdown\r\n                        const columns = ColumnElementManager.getAllColumns();\r\n                        if (existingColumnIndex < columns.length) {\r\n                            const otherColumn = columns[existingColumnIndex];\r\n                            const dropdownContainer = otherColumn.querySelector(`.${DropdownElementManager.getClassName('dropdownContainer')}`);\r\n                            if (dropdownContainer) {\r\n                                const button = dropdownContainer.querySelector(`.${ColumnElementManager.getClassName('columnTitle')}`);\r\n                                if (button) {\r\n                                    const span = button.querySelector('span');\r\n                                    if (span) {\r\n                                        span.textContent = currentButtonText;\r\n                                    }\r\n\r\n                                    button.id = currentButtonText;\r\n                                    button.title = currentButtonText;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // 3. Update the column stack-list reference\r\n                        const updatedHeaders = [...currentColumns];\r\n                        updatedHeaders[currentColumnIndex] = newTitle;\r\n                        updatedHeaders[existingColumnIndex] = currentButtonText;\r\n\r\n                        // Remove old titles and add new ones in correct order\r\n                        ColumnElementManager.swapColumnTitles(currentButtonText, newTitle);\r\n\r\n                        // 4. Skip TableDataModule and directly handle the swap\r\n                        document.dispatchEvent(new CustomEvent('columnManager:columnSwapped', {\r\n                            bubbles: true,\r\n                            detail: {\r\n                                column1: currentButtonText,\r\n                                column2: newTitle,\r\n                                index1: currentColumnIndex,\r\n                                index2: existingColumnIndex\r\n                            }\r\n                        }));\r\n\r\n                    } else {\r\n                        // CASE 2: Adding a new column (use existing logic)\r\n\r\n                        // Update the column title in the manager\r\n                        ColumnElementManager.addColumnTitleAtIndex(currentButtonText, currentColumnIndex, newTitle);\r\n                        this.setButtonText(dropdown, newTitle);\r\n\r\n                        // Trigger data fetch for the newly selected column\r\n                        const currentPage = TableDataModule.getCurrentPage() || 1;\r\n                        const rowCount = RowManagerModule.getRowCount();\r\n\r\n                        // Dispatch event to trigger column data fetch\r\n                        document.dispatchEvent(new CustomEvent('columnManager:columnAdded', {\r\n                            bubbles: true,\r\n                            detail: {\r\n                                column: newTitle,\r\n                                columnIndex: currentColumnIndex,\r\n                                page: currentPage,\r\n                                rowCount: rowCount\r\n                            }\r\n                        }));\r\n\r\n                        // Dispatch event for checkbox handler to check this column\r\n                        document.dispatchEvent(new CustomEvent('columnTitle:changed', {\r\n                            bubbles: true,\r\n                            detail: {\r\n                                oldTitle: currentButtonText,\r\n                                newTitle: newTitle,\r\n                                columnIndex: currentColumnIndex\r\n                            }\r\n                        }));\r\n                    }\r\n\r\n                    this.closeDropdown(dropdown);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        initialize(containers) {\r\n            try {\r\n                if (!instance) {\r\n                    instance = new DropdownManager();\r\n                }\r\n                instance.initializeDropdowns(containers);\r\n                return this;\r\n            } catch (error) {\r\n                console.error('Error initializing dropdowns:', error);\r\n                return null;\r\n            }\r\n        },\r\n        getInstance: () => instance,\r\n        getDropdownInstance: (container) => instance?.getDropdownInstance(container) || null,\r\n        getInstancesByType: (type) => instance?.getInstancesByType(type) || [],\r\n        getCustomRowCount: () => instance?.getCustomRowCount() || null,\r\n        getSelectedRowCount: () => instance?.getSelectedRowCount() || 10,\r\n        hasCustomRowCount: () => instance?.hasCustomRowCount() || false,\r\n        closeAllDropdowns: () => instance?.closeAllDropdowns(),\r\n        enableAllResults: (key) => instance?.enableAllResults(key),\r\n        disableAllResults: () => instance?.disableAllResults(),\r\n        setSelectedRowCount: (rowCount) => instance?.setSelectedRowCount(rowCount) || false,\r\n        getLastSelectedRow: () => instance?.getLastSelectedRow()\r\n    };\r\n})();","/**\r\n * @title PaginationModule\r\n * @description  Handles pagination interactions and dynamic page navigation\r\n * @author Daniel Oliveira\r\n */\r\nconst PaginationModule = (function () {\r\n    // Core state\r\n    let currentPage = 1;\r\n    let totalPages = 1;\r\n    let rowsPerPage = 10; // Default rows per page\r\n\r\n    // Navigation tracking\r\n    let pendingNavigations = new Map(); // Maps page numbers to timestamps\r\n    let lastDispatchedPage = null;\r\n\r\n    // Request cancellation\r\n    let abortController = null;\r\n\r\n    // PAGE STATE MANAGEMENT METHODS\r\n\r\n    /**\r\n     * Recalculates pages based on total items and updates UI\r\n     */\r\n    async function updateMaxPages() {\r\n        try {\r\n            rowsPerPage = DropdownContainerModule.getSelectedRowCount();\r\n\r\n            // Fetch count directly\r\n            const totalItemCount = await TableDataModule.getTotalCount();\r\n            const newTotalPages = Math.max(1, Math.ceil(totalItemCount / rowsPerPage));\r\n\r\n            // Update if needed\r\n            if (newTotalPages !== totalPages) {\r\n                totalPages = newTotalPages;\r\n                updateMaxPageUI();\r\n            }\r\n\r\n            // Fix page if needed\r\n            if (currentPage > totalPages) {\r\n                goToPage(totalPages);\r\n            } else {\r\n                updateButtonStates();\r\n            }\r\n        } catch (error) {\r\n            console.error('Error updating pagination:', error);\r\n            totalPages = 1;\r\n            updateMaxPageUI();\r\n\r\n            if (currentPage !== 1) goToPage(1);\r\n        }\r\n    }\r\n\r\n    function setMaxPage(pages) {\r\n        // Ensure valid number\r\n        pages = Math.max(1, Math.floor(pages));\r\n\r\n        // Only update if changed\r\n        if (pages !== totalPages) {\r\n            totalPages = pages;\r\n            updateMaxPageUI();\r\n\r\n            // Fix current page if needed\r\n            if (currentPage > totalPages) {\r\n                goToPage(totalPages);\r\n            } else {\r\n                updateButtonStates();\r\n            }\r\n\r\n            // Dispatch event for other modules\r\n            document.dispatchEvent(new CustomEvent('pagination:maxPageChanged', {\r\n                bubbles: true,\r\n                detail: { totalPages }\r\n            }));\r\n        }\r\n\r\n        return totalPages;\r\n    }\r\n\r\n    // UI UPDATE METHODS\r\n\r\n    /**\r\n     * Updates current page display in the UI\r\n     */\r\n    function updateCurrentPageUI() {\r\n        PaginationElementManager.setCurrentPageText(currentPage);\r\n    }\r\n\r\n    /**\r\n     * Updates max page display in the UI\r\n     */\r\n    function updateMaxPageUI() {\r\n        PaginationElementManager.setMaxPageText(totalPages);\r\n    }\r\n\r\n    /**\r\n     * Updates navigation button states\r\n     */\r\n    function updateButtonStates() {\r\n        PaginationElementManager.updateButtonStates(currentPage, totalPages);\r\n    }\r\n\r\n    // NAVIGATION METHODS\r\n\r\n    /**\r\n     * Changes to specified page with optimized event dispatching\r\n     */\r\n    function goToPage(page, forceFlag) {\r\n        // Ensure page is within valid range\r\n        page = Math.max(1, Math.min(page, totalPages));\r\n\r\n        // Only process valid page changes\r\n        if (page !== currentPage) {\r\n            const previousPage = currentPage;\r\n\r\n            // Update state immediately\r\n            currentPage = page;\r\n            updateCurrentPageUI();\r\n            updateButtonStates();\r\n\r\n            // Dispatch event with minimal delay\r\n            dispatchPageChangeEvent(previousPage, currentPage, forceFlag);\r\n        } else {\r\n            // Just update UI\r\n            updateButtonStates();\r\n        }\r\n\r\n        // Return a resolved promise to maintain API compatibility\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // EVENT HANDLING METHODS\r\n\r\n    /**\r\n     * Creates and dispatches a page change event with minimal delay\r\n     */\r\n    function dispatchPageChangeEvent(previousPage, newPage, forceFlag) {\r\n        // Cancel any in-progress request\r\n        if (abortController) {\r\n            abortController.abort();\r\n        }\r\n\r\n        // Create a new abort controller for this request\r\n        abortController = new AbortController();\r\n\r\n        // Get required data synchronously\r\n        const rows = RowManagerModule.getAllRows();\r\n        const columns = ColumnElementManager.getColumnHeaders();\r\n\r\n        // Record this navigation attempt\r\n        const timestamp = Date.now();\r\n        pendingNavigations.set(newPage, timestamp);\r\n        lastDispatchedPage = newPage;\r\n\r\n        // Only dispatch if needed data is available\r\n        if (!columns || !rows) {\r\n            console.error('Missing data - cannot dispatch page change event');\r\n            return;\r\n        }\r\n\r\n        // Dispatch event immediately without waiting\r\n        if (!forceFlag) {\r\n            requestAnimationFrame(() => {\r\n                // Only dispatch if this is still the most recent request\r\n                if (pendingNavigations.get(newPage) === timestamp) {\r\n                    document.dispatchEvent(new CustomEvent('pagination:pageChanged', {\r\n                        bubbles: true,\r\n                        detail: {\r\n                            previousPage,\r\n                            page: newPage,\r\n                            rows,\r\n                            columns,\r\n                            rowsPerPage,\r\n                            signal: abortController.signal,\r\n                            timestamp\r\n                        }\r\n                    }));\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up event listeners with optimized handlers\r\n     */\r\n    function setupEventListeners() {\r\n        setupNavigationButtonListeners();\r\n        setupDataEventListeners();\r\n        setupSortSearchEventListeners();\r\n        setupRowCountChangeListener();\r\n        setupPaginationStateListener();\r\n    }\r\n\r\n    function setupNavigationButtonListeners() {\r\n        const buttons = {\r\n            next: PaginationElementManager.getNext(),\r\n            prev: PaginationElementManager.getPrevious(),\r\n            fastForward: PaginationElementManager.getFastForward(),\r\n            fastBack: PaginationElementManager.getFastBackward()\r\n        };\r\n\r\n        // Add optimized click handlers\r\n        if (buttons.next) {\r\n            buttons.next.addEventListener('click', function(e) {\r\n                if (!this.classList.contains('disabled')) {\r\n                    e.preventDefault();\r\n                    goToPage(currentPage + 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (buttons.prev) {\r\n            buttons.prev.addEventListener('click', function(e) {\r\n                if (!this.classList.contains('disabled')) {\r\n                    e.preventDefault();\r\n                    goToPage(currentPage - 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (buttons.fastForward) {\r\n            buttons.fastForward.addEventListener('click', function(e) {\r\n                if (!this.classList.contains('disabled')) {\r\n                    e.preventDefault();\r\n                    goToPage(totalPages);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (buttons.fastBack) {\r\n            buttons.fastBack.addEventListener('click', function(e) {\r\n                if (!this.classList.contains('disabled')) {\r\n                    e.preventDefault();\r\n                    goToPage(1);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function setupDataEventListeners() {\r\n        // Listen for data loading completion\r\n        document.addEventListener('dataApplier:pageDataApplied', function(event) {\r\n            // Clean up navigation tracking\r\n            if (event.detail?.page) {\r\n                pendingNavigations.delete(event.detail.page);\r\n            }\r\n        });\r\n    }\r\n\r\n    function setupSortSearchEventListeners() {\r\n        // Handle sorting and search events\r\n        document.addEventListener('sort:applied', (event) => {\r\n            if (event.detail && currentPage !== 1) {\r\n                goToPage(1);\r\n            }\r\n        });\r\n\r\n        document.addEventListener('sort:cleared', (event) => {\r\n            if (currentPage !== 1) {\r\n                goToPage(1);\r\n            }\r\n        });\r\n\r\n        document.addEventListener('search:performed', (event) => {\r\n            if (currentPage !== 1) {\r\n                goToPage(1, true);\r\n            }\r\n        });\r\n\r\n        document.addEventListener('search:cleared', (event) => {\r\n            if (currentPage !== 1) {\r\n                goToPage(1, true);\r\n            }\r\n        });\r\n    }\r\n\r\n    function setupRowCountChangeListener() {\r\n        // Handle row count changes\r\n        document.addEventListener('dropdown:rowCountChanged', async (event) => {\r\n            if (event.detail?.rowCount) {\r\n                rowsPerPage = event.detail.rowCount;\r\n                \r\n                try {\r\n                    // Recalculate pagination\r\n                    const totalItemCount = await TableDataModule.getTotalCount();\r\n                    totalPages = Math.max(1, Math.ceil(totalItemCount / rowsPerPage));\r\n                    \r\n                    // Update UI\r\n                    updateMaxPageUI();\r\n                    \r\n                    // Fix page if needed\r\n                    if (currentPage > totalPages) {\r\n                        goToPage(totalPages);\r\n                    } else {\r\n                        updateButtonStates();\r\n                        // Notify about the change\r\n                        document.dispatchEvent(new CustomEvent('pagination:rowCountUpdated', {\r\n                            bubbles: true,\r\n                            detail: { page: currentPage, rowsPerPage }\r\n                        }));\r\n                    }\r\n                } catch (error) {\r\n                    console.error('Error updating pagination after row count change:', error);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    function setupPaginationStateListener() {\r\n        // Handle pagination state updates\r\n        document.addEventListener('pagination:stateUpdated', (event) => {\r\n            if (event.detail) {\r\n                const { page, totalPages: newTotalPages, totalCount } = event.detail;\r\n                \r\n                // Update total pages if provided\r\n                if (newTotalPages !== undefined) {\r\n                    totalPages = newTotalPages;\r\n                    updateMaxPageUI();\r\n                    \r\n                    if (totalPages === 1) {\r\n                        DropdownContainerModule.enableAllResults(totalCount);\r\n                        DropdownContainerModule.setSelectedRowCount(totalCount);\r\n                    } else {\r\n                        DropdownContainerModule.disableAllResults();\r\n                    }\r\n                }\r\n                // Recalculate if total count available\r\n                else if (totalCount !== undefined) {\r\n                    const currentRowsPerPage = DropdownContainerModule?.getSelectedRowCount?.() || rowsPerPage;\r\n                    const calculatedTotalPages = Math.max(1, Math.ceil(totalCount / currentRowsPerPage));\r\n\r\n                    if (calculatedTotalPages !== totalPages) {\r\n                        totalPages = calculatedTotalPages;\r\n                        updateMaxPageUI();\r\n                    }\r\n                }\r\n\r\n                // Update navigation\r\n                updateButtonStates();\r\n\r\n                // Fix page if needed\r\n                if (currentPage > totalPages) {\r\n                    goToPage(totalPages);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // INITIALIZATION\r\n\r\n    /**\r\n     * Sets up the pagination system\r\n     */\r\n    async function initialize() {\r\n        // Get initial rows per page setting\r\n        if (DropdownContainerModule?.getSelectedRowCount) {\r\n            rowsPerPage = DropdownContainerModule.getSelectedRowCount();\r\n        }\r\n\r\n        await updateMaxPages();\r\n        currentPage = 1;  // Start at first page\r\n        updateCurrentPageUI();\r\n        setupEventListeners();\r\n\r\n        // Final sync check after short delay\r\n        setTimeout(() => {\r\n            updateMaxPages();\r\n        }, 100);\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        initialize,\r\n        goToPage,\r\n        updateMaxPages,\r\n        updateButtonStates,\r\n        setMaxPage,\r\n        getCurrentPage: () => currentPage,\r\n        getTotalPages: () => totalPages,\r\n        getRowsPerPage: () => rowsPerPage,\r\n        getPendingNavigationCount: () => pendingNavigations.size\r\n    };\r\n})();","/**\r\n * @title RowManagerModule\r\n * @description  Manages the creation and deletion of table rows\r\n * @author Daniel Oliveira\r\n */\r\n\r\nconst RowManagerModule = (function () {\r\n    let instance = null;\r\n\r\n    class RowManager {\r\n        constructor() {\r\n            PerformanceTracker.start('rowManagerInit');\r\n\r\n            // Check dependencies\r\n            if (!RowElementManager.getInstance()) {\r\n                throw new Error('RowElementManager must be initialized before RowManagerModule');\r\n            }\r\n\r\n            if (!ColumnElementManager.getInstance()) {\r\n                throw new Error('ColumnElementManager must be initialized before RowManagerModule');\r\n            }\r\n\r\n            this.rowInsertionPoint = RowElementManager.getRowInsertionPoint();\r\n            if (!this.rowInsertionPoint) {\r\n                throw new Error('Row insertion point not found');\r\n            }\r\n\r\n            this.rowCount = RowElementManager.getRowCount();\r\n            PerformanceTracker.end('rowManagerInit');\r\n        }\r\n\r\n        // ROW CREATION METHODS\r\n\r\n        /**\r\n         * Creates a single row element\r\n         */\r\n        createRow() {\r\n            PerformanceTracker.start('createRow');\r\n            const columnCount = ColumnElementManager.getColumnCount();\r\n            const row = RowElementManager.createRowTemplate(columnCount);\r\n            PerformanceTracker.end('createRow');\r\n            return row;\r\n        }\r\n\r\n        /**\r\n         * Adds specified number of rows\r\n         */\r\n        addRows(count, forceFlag = false) {\r\n            \r\n            PerformanceTracker.start('addRows');\r\n\r\n            count = this._validateCount(count);\r\n            if (count <= 0) {\r\n                PerformanceTracker.end('addRows');\r\n                return [];\r\n            }\r\n\r\n            const addedRows = [];\r\n            for (let i = 0; i < count; i++) {\r\n                addedRows.push(this.createRow());\r\n            }\r\n\r\n            // Use ElementManager for DOM manipulation\r\n            RowElementManager.appendRows(addedRows, this.rowInsertionPoint);\r\n            this.rowCount += count;\r\n\r\n            // Notify about the change\r\n            this._handleRowAddedNotification(addedRows, count);\r\n\r\n            PerformanceTracker.end('addRows');\r\n            return addedRows;\r\n        }\r\n\r\n        /**\r\n         * Removes specified number of rows from end\r\n         */\r\n        removeRows(count) {\r\n            PerformanceTracker.start('removeRows');\r\n\r\n            count = this._validateCount(count);\r\n            if (count <= 0) {\r\n                PerformanceTracker.end('removeRows');\r\n                return;\r\n            }\r\n\r\n            const rowsToRemove = Math.min(count, this.rowCount);\r\n\r\n            // Use ElementManager for DOM manipulation\r\n            const removedRows = RowElementManager.removeLastNRows(rowsToRemove, this.rowInsertionPoint);\r\n            this.rowCount -= rowsToRemove;\r\n\r\n            // Notify about the change\r\n            this._dispatchRowEvent('rowsRemoved', { count: rowsToRemove, rows: removedRows });\r\n\r\n            PerformanceTracker.end('removeRows');\r\n        }\r\n\r\n        // ROW COUNT MANAGEMENT\r\n\r\n        /**\r\n         * Sets the table to have a specific number of rows\r\n         */\r\n        setRowCount(targetCount, forceFlag) {\r\n            PerformanceTracker.start('setRowCount');\r\n\r\n            targetCount = this._validateCount(targetCount);\r\n            if (targetCount === this.rowCount) {\r\n                PerformanceTracker.end('setRowCount');\r\n                return;\r\n            }\r\n\r\n            // Add or remove rows to reach target\r\n            targetCount > this.rowCount\r\n                ? this.addRows(targetCount - this.rowCount, forceFlag)\r\n                : this.removeRows(this.rowCount - targetCount);\r\n\r\n            PerformanceTracker.end('setRowCount');\r\n        }\r\n\r\n        /**\r\n         * Sets row count with data application\r\n         */\r\n        async setRowCountWithData(targetCount, forceFlag) {\r\n            PerformanceTracker.start('setRowCountWithData');\r\n\r\n            targetCount = this._validateCount(targetCount);\r\n            if (targetCount === this.rowCount) {\r\n                PerformanceTracker.end('setRowCountWithData');\r\n                return [];\r\n            }\r\n\r\n            // Update row count\r\n            this.setRowCount(targetCount, forceFlag);\r\n            PerformanceTracker.end('setRowCountWithData');\r\n\r\n            // Return newly added rows for compatibility\r\n            return targetCount > this.rowCount\r\n                ? RowElementManager.getLastNRows(targetCount - this.rowCount)\r\n                : [];\r\n        }\r\n\r\n        /**\r\n         * Clears all rows\r\n         */\r\n        deleteAllRows() {\r\n            PerformanceTracker.start('deleteAllRows');\r\n            if (this.rowCount > 0) {\r\n                this.removeRows(this.rowCount);\r\n            }\r\n            PerformanceTracker.end('deleteAllRows');\r\n        }\r\n\r\n        // ROW CONTENT MANAGEMENT\r\n\r\n        /**\r\n         * Clears row data without removing row DOM elements\r\n         */\r\n        clearRowData() {\r\n            PerformanceTracker.start('clearRowData');\r\n\r\n            const rows = this.getAllRows();\r\n\r\n            // Use ElementManager for DOM manipulation\r\n            RowElementManager.clearRowsContent(rows);\r\n\r\n            PerformanceTracker.end('clearRowData');\r\n            return rows;\r\n        }\r\n\r\n        // ROW STATE MANAGEMENT\r\n\r\n        /**\r\n         * Closes all expanded detail panels\r\n         */\r\n        closeAllExpandedRows() {\r\n            PerformanceTracker.start('closeAllExpandedRows');\r\n\r\n            const rows = this.getAllRows();\r\n\r\n            rows.forEach(row => {\r\n                if (row.dataset.expanded === \"true\") {\r\n                    RowElementManager.collapseExpandedRow(row);\r\n                }\r\n            });\r\n\r\n            PerformanceTracker.end('closeAllExpandedRows');\r\n        }\r\n\r\n        // GETTER METHODS\r\n\r\n        /**\r\n         * Returns current row count\r\n         */\r\n        getRowCount() {\r\n            return this.rowCount;\r\n        }\r\n\r\n        /**\r\n         * Gets all table rows\r\n         */\r\n        getAllRows() {\r\n            return RowElementManager.getAllRows(true);\r\n        }\r\n\r\n        /**\r\n         * Gets row at specific index\r\n         */\r\n        getRowByIndex(index) {\r\n            return RowElementManager.getRowByIndex(index, true);\r\n        }\r\n\r\n        // UTILITY METHODS\r\n\r\n        /**\r\n         * Validate and normalize count input\r\n         */\r\n        _validateCount(count) {\r\n            count = parseInt(count, 10) || 0;\r\n            return Math.max(0, count);\r\n        }\r\n\r\n        /**\r\n         * Handle row added notification with pagination checks\r\n         */\r\n        _handleRowAddedNotification(addedRows, count) {\r\n            const maxPageText = PaginationElementManager.getMaxPage().textContent;\r\n            const maxPage = parseInt(maxPageText.match(/\\d+/)[0], 10);\r\n            const currentPage = parseInt(PaginationElementManager.getCurrentPage().textContent, 10);\r\n\r\n            TableDataModule.getTotalCount().then(totalCount => {\r\n                const itemsRemaining = totalCount - ((maxPage - 1) * DropdownContainerModule.getSelectedRowCount());\r\n\r\n                if ((maxPage !== currentPage) || maxPage === 1) {\r\n                    console.log(\"RowElementManager.getRowCount() is\", RowElementManager.getRowCount());\r\n                    console.log(\"RowElementManager.getRowCount() - count is\", RowElementManager.getRowCount() - count);\r\n                    console.log(\"itemsRemaining is\", itemsRemaining);\r\n                   \r\n                        this._dispatchRowEvent('rowsAdded', { count, rows: addedRows });\r\n                    \r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Sends event about row changes\r\n         */\r\n        _dispatchRowEvent(eventName, detail) {\r\n            this.rowInsertionPoint.dispatchEvent(new CustomEvent(`rowManager:${eventName}`, {\r\n                bubbles: true,\r\n                detail\r\n            }));\r\n        }\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        /**\r\n         * Creates manager instance\r\n         */\r\n        initialize() {\r\n            PerformanceTracker.start('rowManagerInitialize');\r\n            try {\r\n                if (!instance) {\r\n                    instance = new RowManager();\r\n                }\r\n            } catch (error) {\r\n                console.error('Error initializing RowManager:', error);\r\n                PerformanceTracker.end('rowManagerInitialize');\r\n                throw error;\r\n            }\r\n            PerformanceTracker.end('rowManagerInitialize');\r\n            return instance;\r\n        },\r\n\r\n        getInstance: () => instance,\r\n\r\n        // Row creation methods\r\n        createRow: () => instance?.createRow() || null,\r\n        addRows: (count) => instance?.addRows(count) || [],\r\n        removeRows: (count) => instance?.removeRows(count),\r\n\r\n        // Row count management\r\n        setRowCount: (count, forceFlag) => instance?.setRowCount(count, forceFlag),\r\n        setRowCountWithData: (count, forceFlag) => instance?.setRowCountWithData(count, forceFlag) || Promise.resolve([]),\r\n        deleteAllRows: () => instance?.deleteAllRows(),\r\n\r\n        // Row content management\r\n        clearRowData: () => instance?.clearRowData(),\r\n\r\n        // Row state management\r\n        closeAllExpandedRows: () => instance?.closeAllExpandedRows(),\r\n\r\n        // Getter methods\r\n        getRowCount: () => instance?.getRowCount() || 0,\r\n        getAllRows: () => instance?.getAllRows() || [],\r\n        getRowByIndex: (index) => instance?.getRowByIndex(index) || null\r\n    };\r\n})();","/**\r\n * @title SearchBarModule\r\n * @description   Manages the interaction with the search bar and dispatches\r\n *                search events to the system\r\n * @author Daniel Oliveira\r\n */\r\nconst SearchBarModule = (function () {\r\n    // Module state\r\n    const elements = {};\r\n    let currentSearchType = '';\r\n    let searchTimeout = null;\r\n    const SEARCH_DELAY = 300; // ms delay after typing\r\n\r\n    // SEARCH LOGIC METHODS\r\n\r\n    /**\r\n     * Extracts search type from placeholder text\r\n     */\r\n    function extractSearchType(placeholder) {\r\n        if (!placeholder) return '';\r\n        const match = placeholder.match(/Search by (.+)/i);\r\n        return match?.[1]?.trim() || '';\r\n    }\r\n\r\n    /**\r\n     * Performs search with current input\r\n     */\r\n    function performSearch() {\r\n        const searchTerm = elements.input.value.trim();\r\n\r\n        if (searchTerm.length === 0) {\r\n            document.dispatchEvent(new CustomEvent('search:cleared', { bubbles: true }));\r\n            return;\r\n        }\r\n\r\n        const searchType = extractSearchType(elements.input.placeholder || '');\r\n\r\n        // Get current row count\r\n        const rowCount = DropdownContainerModule?.getSelectedRowCount?.() ||\r\n            RowManagerModule.getRowCount();\r\n\r\n        // Send search request\r\n        document.dispatchEvent(new CustomEvent('search:performed', {\r\n            bubbles: true,\r\n            detail: {\r\n                term: searchTerm,\r\n                type: searchType,\r\n                page: PaginationModule.getCurrentPage(),\r\n                rowCount\r\n            }\r\n        }));\r\n    }\r\n\r\n    // EVENT HANDLING METHODS\r\n\r\n    /**\r\n     * Sets up input event handlers\r\n     */\r\n    function setupInputHandler() {\r\n        if (!elements.input) return;\r\n\r\n        elements.input.addEventListener('input', () => {\r\n            // Update UI\r\n            const isEmpty = elements.input.value.length === 0;\r\n            updateClearButtonVisibility(!isEmpty);\r\n            SortIndicatorModule.clearAllSortIndicatorsReset();\r\n\r\n            // Debounce search\r\n            clearTimeout(searchTimeout);\r\n            searchTimeout = setTimeout(performSearch, SEARCH_DELAY);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets up clear button handler\r\n     */\r\n    function setupClearButtonHandler() {\r\n        if (!elements.clear) return;\r\n\r\n        elements.clear.addEventListener('click', () => {\r\n            clearSearch();\r\n            elements.input.focus();\r\n        });\r\n    }\r\n\r\n    // UI UPDATE METHODS\r\n\r\n    /**\r\n     * Updates clear button visibility\r\n     */\r\n    function updateClearButtonVisibility(isVisible) {\r\n        if (!elements.clear) return;\r\n\r\n        SearchElementManager.updateClearButtonVisibility(elements.clear, isVisible);\r\n    }\r\n\r\n    /**\r\n     * Clears the search input and dispatches event\r\n     */\r\n    function clearSearch() {\r\n        if (!elements.input) return;\r\n\r\n        SearchElementManager.clearSearchInput(elements.input, elements.clear, elements.container);\r\n\r\n        clearTimeout(searchTimeout);\r\n        searchTimeout = null;\r\n\r\n        document.dispatchEvent(new CustomEvent('search:cleared', { bubbles: true }));\r\n    }\r\n\r\n    // INITIALIZATION\r\n\r\n    /**\r\n     * Sets up the search component\r\n     */\r\n    function initialize(container) {\r\n        try {\r\n            // Initialize dependencies and cache elements\r\n            !SearchElementManager.getInstance() && SearchElementManager.initialize(container);\r\n\r\n            // Cache DOM elements\r\n            elements.input = SearchElementManager.getSearchInput(false);\r\n            elements.clear = SearchElementManager.getClearIcon(false);\r\n            elements.container = SearchElementManager.getSearchContainer(false);\r\n\r\n            if (!elements.input || !elements.clear) {\r\n                console.warn('SearchBarModule: Required elements not found');\r\n                return null;\r\n            }\r\n\r\n            // Set up event handlers\r\n            setupInputHandler();\r\n            setupClearButtonHandler();\r\n\r\n            return this;\r\n        } catch (error) {\r\n            console.error('SearchBarModule: Initialization error:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        initialize,\r\n\r\n        updateSearchPlaceholder(inputElement, buttonText) {\r\n            if (!buttonText) return;\r\n\r\n            const input = inputElement || elements.input;\r\n            if (!input) return;\r\n\r\n            SearchElementManager.updatePlaceholder(input, `Search by ${buttonText}`);\r\n            currentSearchType = buttonText;\r\n\r\n            // Trigger search if input has content\r\n            if (input.value.trim().length > 0) {\r\n                clearTimeout(searchTimeout);\r\n                searchTimeout = setTimeout(performSearch, SEARCH_DELAY);\r\n            }\r\n        },\r\n\r\n        clearSearch() {\r\n            clearSearch();\r\n        },\r\n\r\n        getCurrentSearchType: () => currentSearchType,\r\n        getCurrentSearchTerm: () => elements.input?.value.trim() || '',\r\n        isSearchActive: () => elements.input?.value.trim().length > 0 || false,\r\n        getSearchInput: () => elements.input,\r\n        getSearchContainer: () => elements.container,\r\n        getClearIcon: () => elements.clear,\r\n        refreshElementCache: initialize\r\n    };\r\n})();","/**\r\n * @title SortIndicatorModule\r\n * @description  Registers sort indicators and manages sorting state and events\r\n * @author Daniel Oliveira\r\n */\r\nconst SortIndicatorModule = (function () {\r\n    let instance = null;\r\n\r\n    // Track all registered indicators and the active sort\r\n    const indicators = new Map();\r\n    let activeSort = { container: null, element: null, direction: null, columnIndex: null, source: null };\r\n\r\n    class SortIndicatorManager {\r\n        constructor() {\r\n            // No initialization needed\r\n        }\r\n\r\n        // REGISTRATION METHODS\r\n\r\n        /**\r\n         * Registers a container for sort indicators\r\n         */\r\n        registerContainer(container, columnIndex, options = {}) {\r\n            if (!container) return null;\r\n\r\n            // Check if this container is already registered\r\n            if (indicators.has(container)) {\r\n                return indicators.get(container);\r\n            }\r\n\r\n            // Create sort indicator elements if they don't exist\r\n            let element = container.querySelector(`.${SortIndicatorElementManager.getSortIndicatorsClass()}`);\r\n            let needsEventSetup = false;\r\n\r\n            if (!element) {\r\n                element = SortIndicatorElementManager.createSortIndicatorTemplate();\r\n                container.appendChild(element);\r\n                needsEventSetup = true;\r\n            }\r\n\r\n            // Store in map with metadata\r\n            const indicatorInfo = {\r\n                container,\r\n                element,\r\n                columnIndex,\r\n                isActive: false,\r\n                direction: null,\r\n                source: options.source || 'column', // Default to column if not specified\r\n                columnName: options.columnName || '',\r\n                ...options\r\n            };\r\n\r\n            indicators.set(container, indicatorInfo);\r\n\r\n            // Set up event listeners if needed\r\n            if (needsEventSetup) {\r\n                this.setupSortIndicatorEvents(indicatorInfo);\r\n            }\r\n\r\n            return indicatorInfo;\r\n        }\r\n\r\n        /**\r\n         * Unregisters a container from sort indicator management\r\n         */\r\n        unregisterContainer(container) {\r\n            if (!container || !indicators.has(container)) return;\r\n\r\n            const info = indicators.get(container);\r\n\r\n            // If this is the active sort, clear it\r\n            if (activeSort.container === container) {\r\n                activeSort = { container: null, element: null, direction: null, columnIndex: null, source: null };\r\n            }\r\n\r\n            // Remove from map\r\n            indicators.delete(container);\r\n        }\r\n\r\n        // EVENT HANDLING METHODS\r\n\r\n        /**\r\n         * Sets up event handling for sort indicator clicks\r\n         */\r\n        setupSortIndicatorEvents(indicatorInfo) {\r\n            const { element, container } = indicatorInfo;\r\n            const upTriangle = element.querySelector(`.${SortIndicatorElementManager.getTriangleUpClass()}`);\r\n            const downTriangle = element.querySelector(`.${SortIndicatorElementManager.getTriangleDownClass()}`);\r\n\r\n            if (!upTriangle || !downTriangle) return;\r\n\r\n            upTriangle.addEventListener('click', e => {\r\n                this.handleSortIndicatorClick(indicatorInfo, 'up');\r\n            });\r\n\r\n            downTriangle.addEventListener('click', e => {\r\n                this.handleSortIndicatorClick(indicatorInfo, 'down');\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Registers click events for a parent container to trigger sort indicator toggling\r\n         */\r\n        registerContainerEvents(parentContainer, indicatorContainer) {\r\n            if (!parentContainer || !indicatorContainer) return;\r\n\r\n            // Check if the indicator container is registered\r\n            const indicatorInfo = indicators.get(indicatorContainer);\r\n            if (!indicatorInfo) return;\r\n\r\n            // Remove any existing click handlers to prevent duplicates\r\n            if (parentContainer._sortClickHandler) {\r\n                parentContainer.removeEventListener('click', parentContainer._sortClickHandler);\r\n            }\r\n\r\n            // Create click handler\r\n            parentContainer._sortClickHandler = (e) => {\r\n                // Prevent triggering if click is on the sort indicator itself\r\n                if (e.target.closest(`.${SortIndicatorElementManager.getSortIndicatorsClass()}`)) {\r\n                    return;\r\n                }\r\n\r\n                // Toggle sort direction\r\n                const currentDirection = indicatorInfo.direction;\r\n                const newDirection = !currentDirection ? 'up' :\r\n                    currentDirection === 'up' ? 'down' : 'up';\r\n\r\n                // Trigger sort\r\n                this.handleSortIndicatorClick(indicatorInfo, newDirection);\r\n            };\r\n\r\n            // Add click handler to parent container\r\n            parentContainer.addEventListener('click', parentContainer._sortClickHandler);\r\n        }\r\n\r\n        /**\r\n         * Handles a sort indicator click event\r\n         */\r\n        handleSortIndicatorClick(indicatorInfo, direction) {\r\n            const { container, element, columnIndex, source, columnName } = indicatorInfo;\r\n\r\n            // Toggle if same container/direction is already active\r\n            if (activeSort.container === container && activeSort.direction === direction) {\r\n                this.clearAllSortIndicators();\r\n                return;\r\n            }\r\n\r\n            // Clear all indicators\r\n            this.clearAllSortIndicators();\r\n\r\n            // Clear search if active\r\n            SearchBarModule.clearSearch();\r\n\r\n            // Set active indicator state using ElementManager\r\n            SortIndicatorElementManager.setTriangleState(element, direction, true);\r\n\r\n            // Update active sort state\r\n            activeSort = {\r\n                container,\r\n                element,\r\n                direction,\r\n                columnIndex,\r\n                source,\r\n                columnName\r\n            };\r\n\r\n            indicatorInfo.isActive = true;\r\n            indicatorInfo.direction = direction;\r\n\r\n            // Dispatch event for backend communication\r\n            this.dispatchSortEvent(container, columnIndex, direction, source, columnName);\r\n        }\r\n\r\n        // STATE MANAGEMENT METHODS\r\n\r\n        /**\r\n         * Clears all sort indicators and resets dropdown indicators\r\n         */\r\n        clearAllSortIndicatorsReset() {\r\n            const indicatorsToRemove = [];\r\n\r\n            indicators.forEach(info => {\r\n                // Check if this is a dropdown-specific indicator\r\n                if (info.source === 'dropdown') {\r\n                    // Mark for removal from the indicators Map\r\n                    indicatorsToRemove.push(info.container);\r\n\r\n                    // Remove the element from the DOM using ElementManager\r\n                    SortIndicatorElementManager.removeIndicator(info.element);\r\n                } else {\r\n                    // For standard column indicators, just reset their state\r\n                    SortIndicatorElementManager.clearIndicator(info.element);\r\n                }\r\n\r\n                info.isActive = false;\r\n                info.direction = null;\r\n            });\r\n\r\n            // Remove dropdown indicators from the Map\r\n            indicatorsToRemove.forEach(container => {\r\n                indicators.delete(container);\r\n            });\r\n\r\n            // Reset active sort state\r\n            activeSort = { container: null, element: null, direction: null, columnIndex: null, source: null };\r\n        }\r\n\r\n        /**\r\n         * Clears all sort indicators to inactive state\r\n         */\r\n        clearAllSortIndicators() {\r\n            indicators.forEach(info => {\r\n                SortIndicatorElementManager.clearIndicator(info.element);\r\n                info.isActive = false;\r\n                info.direction = null;\r\n            });\r\n\r\n            activeSort = { container: null, element: null, direction: null, columnIndex: null, source: null };\r\n\r\n            document.dispatchEvent(new CustomEvent('sort:cleared', {\r\n                bubbles: true\r\n            }));\r\n        }\r\n\r\n        // EVENT DISPATCHING\r\n\r\n        /**\r\n         * Dispatches custom event for sort actions\r\n         */\r\n        dispatchSortEvent(container, columnIndex, direction, source, columnName) {\r\n            document.dispatchEvent(new CustomEvent('sortIndicator:sort', {\r\n                bubbles: true,\r\n                detail: {\r\n                    container,\r\n                    columnIndex,\r\n                    direction,\r\n                    source,\r\n                    columnName: columnName || container.textContent.trim()\r\n                }\r\n            }));\r\n        }\r\n\r\n        // GETTER METHODS\r\n\r\n        /**\r\n         * Gets information about the currently active sort\r\n         */\r\n        getActiveSort() {\r\n            return { ...activeSort };\r\n        }\r\n\r\n        /**\r\n         * Gets all registered indicators\r\n         */\r\n        getAllIndicators() {\r\n            return new Map(indicators);\r\n        }\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        /**\r\n         * Initializes the SortIndicatorModule\r\n         */\r\n        initialize() {\r\n            if (!instance) {\r\n                instance = new SortIndicatorManager();\r\n            }\r\n            return instance;\r\n        },\r\n\r\n        /**\r\n         * Gets the singleton instance\r\n         */\r\n        getInstance() {\r\n            return instance;\r\n        },\r\n\r\n        /**\r\n         * Registers a container for sort indicators\r\n         */\r\n        registerContainer(container, columnIndex, options) {\r\n            return instance?.registerContainer(container, columnIndex, options) || null;\r\n        },\r\n\r\n        /**\r\n         * Registers click events for a parent container to trigger sort indicator toggling\r\n         */\r\n        registerContainerEvents(parentContainer, indicatorContainer) {\r\n            return instance?.registerContainerEvents(parentContainer, indicatorContainer);\r\n        },\r\n\r\n        /**\r\n         * Handles a sort indicator click\r\n         */\r\n        handleSortIndicatorClick(container, direction) {\r\n            const info = indicators.get(container);\r\n            if (info) {\r\n                instance?.handleSortIndicatorClick(info, direction);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Clears all sort indicators\r\n         */\r\n        clearAllSortIndicators() {\r\n            return instance?.clearAllSortIndicators();\r\n        },\r\n\r\n        /**\r\n         * Clears all sort indicators and resets dropdown indicators\r\n         */\r\n        clearAllSortIndicatorsReset() {\r\n            return instance?.clearAllSortIndicatorsReset();\r\n        },\r\n\r\n        /**\r\n         * Gets information about the currently active sort\r\n         */\r\n        getActiveSort() {\r\n            return instance?.getActiveSort() || {\r\n                container: null,\r\n                element: null,\r\n                direction: null,\r\n                columnIndex: null,\r\n                source: null\r\n            };\r\n        },\r\n\r\n        /**\r\n         * Unregisters a container\r\n         */\r\n        unregisterContainer(container) {\r\n            return instance?.unregisterContainer(container);\r\n        },\r\n\r\n        /**\r\n         * Gets all registered indicators\r\n         */\r\n        getAllIndicators() {\r\n            return instance?.getAllIndicators() || new Map();\r\n        }\r\n    };\r\n})();","/**\r\n * @title TableDataModule\r\n * @description  Handles data retrieval and event management for table data\r\n * @author Daniel Oliveira\r\n */\r\nconst TableDataModule = (function () {\r\n    // STATE MANAGEMENT\r\n    const state = {\r\n        mode: 'regular',    // 'regular', 'search', or 'sort'\r\n        search: { term: '', type: '' },\r\n        sort: { column: '', direction: '' },\r\n        currentPage: 1,\r\n        isBusy: false\r\n    };\r\n\r\n    // HELPER METHODS\r\n    const getRowsPerPage = (defaultValue = 10) => DropdownContainerModule?.getSelectedRowCount?.() || defaultValue;\r\n    const getColumns = () => ColumnElementManager.getColumnHeaders() || [];\r\n    const getRowCount = () => RowManagerModule.getRowCount();\r\n\r\n    /**\r\n     * Dispatches a data event\r\n     */\r\n    function dispatchEvent(eventName, detail) {\r\n        document.dispatchEvent(new CustomEvent(`tableData:${eventName}`, {\r\n            bubbles: true,\r\n            detail\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Updates pagination state\r\n     */\r\n    function updatePagination(page, totalCount, rowsPerPage) {\r\n        document.dispatchEvent(new CustomEvent('pagination:stateUpdated', {\r\n            bubbles: true,\r\n            detail: {\r\n                page,\r\n                totalPages: Math.max(1, Math.ceil(totalCount / rowsPerPage)),\r\n                totalCount\r\n            }\r\n        }));\r\n    }\r\n\r\n    // DATA RETRIEVAL METHODS\r\n\r\n    /**\r\n     * Fetches data from the API with standardized error handling\r\n     */\r\n    async function fetchData(endpoint, params = {}) {\r\n        // Build query parameters\r\n        const queryParams = Object.entries(params)\r\n            .flatMap(([key, value]) => {\r\n                if (key === 'columns') {\r\n                    const cols = Array.isArray(value) ? value : [value];\r\n                    return cols.map(c => `columns=${encodeURIComponent(c)}`);\r\n                }\r\n                return [`${key}=${encodeURIComponent(value)}`];\r\n            })\r\n            .join('&');\r\n\r\n        const url = `/ProductionHistory/${endpoint}${queryParams ? `?${queryParams}` : ''}`;\r\n\r\n        // Execute request\r\n        const response = await fetch(url, {\r\n            headers: { 'Connection': 'keep-alive' }\r\n        });\r\n\r\n        if (!response.ok) throw new Error(`HTTP error ${response.status}`);\r\n        return await response.json();\r\n    }\r\n\r\n    /**\r\n     * Gets data based on current mode\r\n     */\r\n    async function getData(config) {\r\n        const { page, rowsPerPage, columns } = config;\r\n        let endpoint, params = { page, rowsPerPage, columns };\r\n\r\n        if (state.mode === 'search' && state.search.term) {\r\n            endpoint = 'Search';\r\n            params.term = state.search.term;\r\n            params.type = state.search.type;\r\n        }\r\n        else if (state.mode === 'sort' && state.sort.column) {\r\n            endpoint = 'SortedPageData';\r\n            params.sortColumn = state.sort.column;\r\n            params.sortDirection = state.sort.direction;\r\n        }\r\n        else {\r\n            endpoint = 'GetPageData';\r\n        }\r\n\r\n        return fetchData(endpoint, params);\r\n    }\r\n\r\n    /**\r\n     * Gets total count based on current mode\r\n     */\r\n    async function getTotalCount() {\r\n        if (state.mode === 'search' && state.search.term) {\r\n            return fetchData('SearchCount', {\r\n                term: state.search.term,\r\n                type: state.search.type\r\n            });\r\n        }\r\n\r\n        return fetchData('GetTotalCount');\r\n    }\r\n\r\n    /**\r\n     * Gets range data based on current mode\r\n     */\r\n    async function getRangeData(columns, startIndex, count) {\r\n        let endpoint, params = { startIndex, count, columns };\r\n\r\n        if (state.mode === 'search' && state.search.term) {\r\n            endpoint = 'SearchRange';\r\n            params.term = state.search.term;\r\n            params.type = state.search.type;\r\n        }\r\n        else if (state.mode === 'sort' && state.sort.column) {\r\n            endpoint = 'SortedRangeData';\r\n            params.sortColumn = state.sort.column;\r\n            params.sortDirection = state.sort.direction;\r\n        }\r\n        else {\r\n            endpoint = 'GetRangeJobData';\r\n        }\r\n\r\n        return fetchData(endpoint, params);\r\n    }\r\n\r\n    // MODE MANAGEMENT METHODS\r\n\r\n    /**\r\n     * Sets search mode\r\n     */\r\n    function setSearchMode(term, type) {\r\n        state.mode = 'search';\r\n        state.search = { term, type };\r\n        state.sort = { column: '', direction: '' };\r\n    }\r\n\r\n    /**\r\n     * Sets sort mode\r\n     */\r\n    function setSortMode(column, direction) {\r\n        state.mode = 'sort';\r\n        state.sort = { column, direction };\r\n        state.search = { term: '', type: '' };\r\n    }\r\n\r\n    /**\r\n     * Sets regular mode\r\n     */\r\n    function setRegularMode() {\r\n        state.mode = 'regular';\r\n        state.search = { term: '', type: '' };\r\n        state.sort = { column: '', direction: '' };\r\n    }\r\n\r\n    /**\r\n     * Activates search mode\r\n     */\r\n    function activateSearch(term, type) {\r\n        setSearchMode(term, type);\r\n    }\r\n\r\n    /**\r\n     * Deactivates search mode\r\n     */\r\n    async function deactivateSearch() {\r\n        setRegularMode();\r\n        return await fetchData('GetTotalCount');\r\n    }\r\n\r\n    /**\r\n     * Activates sort mode\r\n     */\r\n    function activateSort(column, direction) {\r\n        setSortMode(column, direction);\r\n    }\r\n\r\n    /**\r\n     * Deactivates sort mode\r\n     */\r\n    async function deactivateSort() {\r\n        setRegularMode();\r\n        return await fetchData('GetTotalCount');\r\n    }\r\n\r\n    // EVENT HANDLERS\r\n\r\n    const handlers = {\r\n        /**\r\n         * Handles rows added event\r\n         */\r\n        async rowsAdded(event) {\r\n            if (state.isBusy) return;\r\n\r\n            const { count, rows } = event.detail;\r\n            if (!rows?.length || !count) return;\r\n\r\n            const columns = getColumns();\r\n            if (!columns.length) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                const currentRowCount = getRowCount();\r\n                const previousRowCount = currentRowCount - count;\r\n                const startIndex = (state.currentPage - 1) * previousRowCount + previousRowCount;\r\n\r\n                // Get data for new rows\r\n                const newRowsData = await getRangeData(columns, startIndex, count);\r\n\r\n                dispatchEvent('rowDataFetched', {\r\n                    rows,\r\n                    data: newRowsData,\r\n                    columns,\r\n                    currentPage: state.currentPage,\r\n                    previousRowCount,\r\n                    addedRowCount: count\r\n                });\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles page changed event\r\n         */\r\n        async pageChanged(event) {\r\n            if (state.isBusy) return;\r\n\r\n            const { page, rows, columns, rowsPerPage } = event.detail;\r\n            if (!columns?.length) return;\r\n\r\n            state.isBusy = true;\r\n\r\n            try {\r\n                // Update current page\r\n                state.currentPage = page;\r\n\r\n                // Get counts\r\n                const totalCount = await getTotalCount();\r\n                const currentRowsPerPage = getRowsPerPage(rowsPerPage || getRowCount());\r\n\r\n                // Calculate items for this page\r\n                const startIndex = (page - 1) * currentRowsPerPage;\r\n                const itemsOnThisPage = Math.min(currentRowsPerPage, totalCount - startIndex);\r\n\r\n                // Check for valid page\r\n                if (startIndex >= totalCount) {\r\n                    const maxValidPage = Math.max(1, Math.ceil(totalCount / currentRowsPerPage));\r\n\r\n                    dispatchEvent('pageOutOfBounds', {\r\n                        currentPage: page,\r\n                        maxValidPage,\r\n                        totalCount,\r\n                        rowsPerPage: currentRowsPerPage\r\n                    });\r\n\r\n                    return;\r\n                }\r\n\r\n                // Fetch page data\r\n                const pageData = await getData({\r\n                    page,\r\n                    rowsPerPage: currentRowsPerPage,\r\n                    columns\r\n                });\r\n\r\n                // Dispatch event with data\r\n                dispatchEvent('pageDataFetched', {\r\n                    page,\r\n                    rowCount: itemsOnThisPage,\r\n                    totalCount,\r\n                    rows,\r\n                    data: pageData,\r\n                    columns,\r\n                    currentRowCount: getRowCount(),\r\n                    needsRowUpdate: getRowCount() !== itemsOnThisPage\r\n                });\r\n\r\n                // Update pagination\r\n                updatePagination(page, totalCount, currentRowsPerPage);\r\n            } catch (error) {\r\n                console.error('Error during page change:', error);\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles column added event\r\n         */\r\n        async columnAdded(event) {\r\n            if (state.isBusy) return;\r\n\r\n            const { column, page, rowCount, columnIndex } = event.detail;\r\n            if (!column) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                const startIndex = (page - 1) * rowCount;\r\n                const columnData = await getRangeData([column], startIndex, rowCount);\r\n\r\n                dispatchEvent('columnDataFetched', {\r\n                    column,\r\n                    columnIndex,\r\n                    data: columnData,\r\n                    page,\r\n                    rowCount,\r\n                    startIndex\r\n                });\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles search performed event\r\n         */\r\n        async searchPerformed(event) {\r\n            if (state.isBusy) return;\r\n\r\n            const { term, type, rowCount } = event.detail;\r\n            if (!term || !type) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                // Activate search mode\r\n                setSearchMode(term, type);\r\n\r\n                // Get columns and count\r\n                const columns = getColumns();\r\n                const searchCount = await getTotalCount();\r\n\r\n                // Reset to page 1\r\n                state.currentPage = 1;\r\n\r\n                // Calculate rows to display\r\n                const rowsPerPage = DropdownContainerModule.getLastSelectedRow();\r\n                const rowsToShow = Math.min(rowsPerPage, searchCount);\r\n\r\n                // Fetch search results\r\n                const searchResults = await getData({\r\n                    page: 1,\r\n                    rowsPerPage: rowsToShow,\r\n                    columns\r\n                });\r\n\r\n                // Dispatch event with results\r\n                dispatchEvent('searchDataFetched', {\r\n                    term,\r\n                    type,\r\n                    page: 1,\r\n                    rowCount: rowsToShow,\r\n                    totalResults: searchCount,\r\n                    columns,\r\n                    data: searchResults,\r\n                    currentRowCount: getRowCount(),\r\n                    needsRowUpdate: getRowCount() !== rowsToShow\r\n                });\r\n\r\n                // Update pagination\r\n                updatePagination(1, searchCount, rowsPerPage);\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles search cleared event\r\n         */\r\n        async searchCleared() {\r\n            if (state.isBusy) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                // Deactivate search\r\n                const totalCount = await deactivateSearch().catch(() => getTotalCount());\r\n\r\n                // Reset to page 1\r\n                state.currentPage = 1;\r\n\r\n                // Get display settings\r\n                const columns = getColumns();\r\n                const rowsPerPage = getRowsPerPage();\r\n                const rowsToShow = Math.min(rowsPerPage, totalCount);\r\n\r\n                // Fetch normal data\r\n                const normalData = await getData({\r\n                    page: 1,\r\n                    rowsPerPage: rowsToShow,\r\n                    columns\r\n                });\r\n\r\n                // Dispatch event with data\r\n                dispatchEvent('searchCleared', {\r\n                    page: 1,\r\n                    rowCount: rowsToShow,\r\n                    totalCount,\r\n                    columns,\r\n                    data: normalData,\r\n                    currentRowCount: getRowCount(),\r\n                    needsRowUpdate: getRowCount() !== rowsToShow\r\n                });\r\n\r\n                // Update pagination\r\n                updatePagination(1, totalCount, rowsPerPage);\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles sort applied event\r\n         */\r\n        async sortApplied(event) {\r\n            if (state.isBusy) return;\r\n\r\n            const { column, direction, columns } = event.detail;\r\n            if (!column || !direction || !columns?.length) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                // Activate sort mode\r\n                setSortMode(column, direction);\r\n\r\n                // Get total count\r\n                const totalCount = await getTotalCount();\r\n\r\n                // Reset to page 1\r\n                state.currentPage = 1;\r\n\r\n                // Get display settings\r\n                const rowsPerPage = getRowsPerPage();\r\n                const rowsToShow = Math.min(rowsPerPage, totalCount);\r\n\r\n                // Fetch sorted data\r\n                const sortedData = await getData({\r\n                    page: 1,\r\n                    rowsPerPage: rowsToShow,\r\n                    columns\r\n                });\r\n\r\n                // Dispatch event with data\r\n                dispatchEvent('sortDataFetched', {\r\n                    column,\r\n                    direction,\r\n                    page: 1,\r\n                    rowCount: rowsToShow,\r\n                    totalCount,\r\n                    columns,\r\n                    data: sortedData,\r\n                    currentRowCount: getRowCount(),\r\n                    needsRowUpdate: getRowCount() !== rowsToShow\r\n                });\r\n\r\n                // Update pagination\r\n                updatePagination(1, totalCount, rowsPerPage);\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles sort cleared event\r\n         */\r\n        async sortCleared() {\r\n            if (state.isBusy) return;\r\n\r\n            state.isBusy = true;\r\n            try {\r\n                // Deactivate sort\r\n                const totalCount = await deactivateSort().catch(() => getTotalCount());\r\n\r\n                // Reset to page 1\r\n                state.currentPage = 1;\r\n\r\n                // Get display settings\r\n                const columns = getColumns();\r\n                const rowsPerPage = getRowsPerPage();\r\n                const rowsToShow = Math.min(rowsPerPage, totalCount);\r\n\r\n                // Fetch normal data\r\n                const normalData = await getData({\r\n                    page: 1,\r\n                    rowsPerPage: rowsToShow,\r\n                    columns\r\n                });\r\n\r\n                // Dispatch event with data\r\n                dispatchEvent('sortCleared', {\r\n                    page: 1,\r\n                    rowCount: rowsToShow,\r\n                    totalCount,\r\n                    columns,\r\n                    data: normalData,\r\n                    currentRowCount: getRowCount(),\r\n                    needsRowUpdate: getRowCount() !== rowsToShow\r\n                });\r\n\r\n                // Update pagination\r\n                updatePagination(1, totalCount, rowsPerPage);\r\n            } finally {\r\n                state.isBusy = false;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Handles sort indicator sort event\r\n         */\r\n        sortIndicatorSort(event) {\r\n            const { direction, columnName } = event.detail;\r\n\r\n            // Update sort state\r\n            setSortMode(columnName, direction);\r\n\r\n            // Trigger data fetch\r\n            document.dispatchEvent(new CustomEvent('sort:applied', {\r\n                bubbles: true,\r\n                detail: {\r\n                    column: columnName,\r\n                    direction,\r\n                    columns: getColumns()\r\n                }\r\n            }));\r\n        }\r\n    };\r\n\r\n    // PUBLIC API\r\n    return {\r\n        // Data retrieval methods\r\n        getPageData(page, rowsPerPage, columns) {\r\n            return getData({ page, rowsPerPage, columns });\r\n        },\r\n\r\n        getTotalCount,\r\n\r\n        getRangeJobData(columns, startIndex, count) {\r\n            return getRangeData(columns, startIndex, count);\r\n        },\r\n\r\n        handleRowCountChange(currentPage, currentRowCount, rowCountChange, columns) {\r\n            const startIndex = (currentPage - 1) * currentRowCount + currentRowCount;\r\n            return getRangeData(columns, startIndex, rowCountChange);\r\n        },\r\n\r\n        // Mode management methods\r\n        activateSearch,\r\n        activateSort,\r\n        deactivateSearch,\r\n        deactivateSort,\r\n\r\n        // State accessors\r\n        isSearchModeActive: () => state.mode === 'search',\r\n        isSortModeActive: () => state.mode === 'sort',\r\n        getCurrentSearchTerm: () => state.search.term,\r\n        getCurrentSearchType: () => state.search.type,\r\n        getCurrentSortColumn: () => state.sort.column,\r\n        getCurrentSortDirection: () => state.sort.direction,\r\n        getCurrentPage: () => state.currentPage,\r\n        setCurrentPage: (page) => { state.currentPage = page; },\r\n\r\n        // Initialization\r\n        initialize() {\r\n            document.addEventListener('rowManager:rowsAdded', handlers.rowsAdded);\r\n            document.addEventListener('pagination:pageChanged', handlers.pageChanged);\r\n            document.addEventListener('columnManager:columnAdded', handlers.columnAdded);\r\n            document.addEventListener('search:performed', handlers.searchPerformed);\r\n            document.addEventListener('search:cleared', handlers.searchCleared);\r\n            document.addEventListener('sort:applied', handlers.sortApplied);\r\n            document.addEventListener('sort:cleared', handlers.sortCleared);\r\n            document.addEventListener('sortIndicator:sort', handlers.sortIndicatorSort);\r\n\r\n            return this;\r\n        }\r\n    };\r\n})();","const TableTitleModule = (function () {\r\n    let instance = null;\r\n\r\n    // STATE MANAGEMENT\r\n\r\n    // Cache DOM elements\r\n    const elements = {\r\n        titleContainer: null,\r\n        titleHeading: null,\r\n        subtitle: null\r\n    };\r\n\r\n    // Track current state\r\n    const state = {\r\n        mode: 'regular', // 'regular', 'search', or 'sort'\r\n        search: { term: '', type: '', totalResults: 0 },\r\n        sort: { column: '', direction: '' },\r\n        normalCount: 0, // Single source of truth for total count\r\n        initialized: false\r\n    };\r\n\r\n    class TableTitleManager {\r\n        constructor() {\r\n            this.sortingInProgress = false;\r\n            this.initializeElements();\r\n            this.setupEventListeners();\r\n        }\r\n\r\n        // DOM METHODS\r\n\r\n        /**\r\n         * Initialize DOM elements\r\n         */\r\n        initializeElements() {\r\n            // Get title element using TableElementManager\r\n            elements.titleContainer = TableElementManager.getTableTitle(true);\r\n            if (!elements.titleContainer) {\r\n                return;\r\n            }\r\n\r\n            elements.titleHeading = TableElementManager.getTableTitleHeading(true);\r\n\r\n            // Create subtitle element if it doesn't exist\r\n            elements.subtitle = this.getOrCreateSubtitle();\r\n\r\n            // Set initial title text\r\n            this.setInitialTitle();\r\n\r\n            // Try to initialize immediately if possible\r\n            this.attemptInitialization();\r\n        }\r\n\r\n        /**\r\n         * Gets existing subtitle or creates new one\r\n         */\r\n        getOrCreateSubtitle() {\r\n            const existingSubtitle = elements.titleContainer.querySelector('.data-table__subtitle');\r\n            if (existingSubtitle) {\r\n                return existingSubtitle;\r\n            }\r\n\r\n            const subtitle = document.createElement('h6');\r\n            subtitle.classList.add('data-table__subtitle');\r\n            elements.titleContainer.appendChild(subtitle);\r\n            return subtitle;\r\n        }\r\n\r\n        /**\r\n         * Sets initial title text\r\n         */\r\n        setInitialTitle() {\r\n            if (elements.titleHeading) {\r\n                TableElementManager.updateTitleText(elements.titleHeading, 'Showing All Data');\r\n            }\r\n\r\n            if (elements.subtitle) {\r\n                TableElementManager.updateSubtitleText(elements.subtitle, 'Loading...');\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Update title for search state\r\n         */\r\n        updateTitleForSearchState() {\r\n            if (!elements.titleHeading || !elements.subtitle) return;\r\n\r\n            const { term, totalResults } = state.search;\r\n            const resultText = `${totalResults} result${totalResults !== 1 ? 's' : ''} found`;\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                elements.titleHeading.textContent = `Search for \"${term}\"`;\r\n                elements.subtitle.textContent = resultText;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Update title for sort state\r\n         */\r\n        updateTitleForSortState() {\r\n            if (!elements.titleHeading || !elements.subtitle) return;\r\n\r\n            const { column, direction } = state.sort;\r\n            const directionText = direction === 'up' ? 'ascending' : 'descending';\r\n            const totalCount = state.normalCount;\r\n            \r\n            const subtitleText = totalCount === 0 ?\r\n                `${directionText}  loading...` :\r\n                `${totalCount} item${totalCount !== 1 ? 's' : ''} | ${directionText} `;\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                elements.titleHeading.textContent = `Sorted by ${column}`;\r\n                elements.subtitle.textContent = subtitleText;\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Update title for normal state\r\n         */\r\n        updateTitleForNormalState() {\r\n            if (!elements.titleHeading || !elements.subtitle) return;\r\n\r\n            const totalCount = state.normalCount;\r\n            const countText = `${totalCount} item${totalCount !== 1 ? 's' : ''}`;\r\n\r\n            DOMUtils.batchUpdate(() => {\r\n                elements.titleHeading.textContent = `Showing All Data`;\r\n                elements.subtitle.textContent = countText;\r\n            });\r\n        }\r\n\r\n        // DATA INITIALIZATION METHODS\r\n\r\n        /**\r\n         * Attempt to initialize the title with data from TableDataModule\r\n         */\r\n        attemptInitialization() {\r\n            if (typeof TableDataModule === 'undefined') return;\r\n\r\n            TableDataModule.getTotalCount()\r\n                .then(count => {\r\n                    if (count > 0) {\r\n                        state.normalCount = count;\r\n                        this.updateTitleForNormalState();\r\n                        state.initialized = true;\r\n                    }\r\n                })\r\n                .catch(() => {\r\n                    // Silent fail, will be retried later\r\n                });\r\n        }\r\n\r\n        // EVENT SETUP METHODS\r\n\r\n        /**\r\n         * Set up event listeners for state changes\r\n         */\r\n        setupEventListeners() {\r\n            // Search events\r\n            document.addEventListener('tableData:searchDataFetched', this.handleSearchData.bind(this));\r\n            document.addEventListener('tableData:searchCleared', this.handleSearchCleared.bind(this));\r\n\r\n            // Sort events\r\n            document.addEventListener('tableData:sortDataFetched', this.handleSortData.bind(this));\r\n            document.addEventListener('sort:cleared', this.handleSortCleared.bind(this));\r\n            document.addEventListener('sort:applied', this.handleSortApplied.bind(this));\r\n            document.addEventListener('sortIndicator:sort', this.handleSortIndicatorSort.bind(this));\r\n\r\n            // Normal data events\r\n            document.addEventListener('tableData:pageDataFetched', this.handlePageData.bind(this));\r\n        }\r\n\r\n        // EVENT HANDLERS\r\n\r\n        /**\r\n         * Handle search data fetched event\r\n         */\r\n        handleSearchData(event) {\r\n            const { term, type, totalResults } = event.detail;\r\n\r\n            state.mode = 'search';\r\n            state.search = { term, type, totalResults };\r\n            state.initialized = true;\r\n\r\n            this.updateTitleForSearchState();\r\n        }\r\n\r\n        /**\r\n         * Handle sort applied event (direct from SortIndicatorModule)\r\n         */\r\n        handleSortApplied(event) {\r\n            const { column, direction } = event.detail;\r\n\r\n            this.sortingInProgress = true;\r\n            state.mode = 'sort';\r\n            state.sort = { column, direction };\r\n            state.initialized = true;\r\n\r\n            this.updateTitleForSortState();\r\n        }\r\n\r\n        /**\r\n         * Handle sort indicator sort event (direct from SortIndicatorModule)\r\n         */\r\n        handleSortIndicatorSort(event) {\r\n            const { columnName, direction } = event.detail;\r\n\r\n            this.sortingInProgress = true;\r\n            state.mode = 'sort';\r\n            state.sort = { column: columnName, direction };\r\n            state.initialized = true;\r\n\r\n            this.updateTitleForSortState();\r\n        }\r\n\r\n        /**\r\n         * Handle search cleared event\r\n         */\r\n        handleSearchCleared(event) {\r\n            const { totalCount } = event.detail;\r\n\r\n            state.mode = 'regular';\r\n            state.normalCount = totalCount;\r\n            state.initialized = true;\r\n\r\n            this.updateTitleForNormalState();\r\n        }\r\n\r\n        /**\r\n         * Handle sort data fetched event\r\n         */\r\n        handleSortData(event) {\r\n            const { column, direction, totalCount } = event.detail;\r\n\r\n            // Update normalCount if provided and not already set\r\n            if (totalCount && (!state.normalCount || state.normalCount === 0)) {\r\n                state.normalCount = totalCount;\r\n            }\r\n\r\n            state.mode = 'sort';\r\n            state.sort = { column, direction };\r\n            state.initialized = true;\r\n\r\n            this.updateTitleForSortState();\r\n            this.sortingInProgress = false;\r\n        }\r\n\r\n        /**\r\n         * Handle sort cleared event\r\n         */\r\n        handleSortCleared() {\r\n            // Only process if we're not in the middle of a search operation\r\n            if (state.mode === 'search') return;\r\n\r\n            state.mode = 'regular';\r\n\r\n            // Use cached normalCount or set to a loading state\r\n            if (state.normalCount > 0) {\r\n                this.updateTitleForNormalState();\r\n            } else {\r\n                DOMUtils.batchUpdate(() => {\r\n                    elements.titleHeading.textContent = `Showing All Data`;\r\n                    elements.subtitle.textContent = `Loading...`;\r\n                });\r\n\r\n                this.attemptInitialization();\r\n            }\r\n\r\n            state.initialized = true;\r\n        }\r\n\r\n        /**\r\n         * Handle normal page data fetched event\r\n         */\r\n        handlePageData(event) {\r\n            // Only update if we're in regular mode and not sorting\r\n            if (state.mode !== 'regular' || this.sortingInProgress) return;\r\n\r\n            const { totalCount } = event.detail;\r\n\r\n            // Always update normalCount as reference for other modes\r\n            state.normalCount = totalCount;\r\n            state.initialized = true;\r\n            this.updateTitleForNormalState();\r\n        }\r\n\r\n        // PUBLIC METHODS\r\n\r\n        /**\r\n         * Force title update based on current state\r\n         */\r\n        refreshTitle() {\r\n            // If not initialized yet, try to get count data\r\n            if (!state.initialized) {\r\n                this.attemptInitialization();\r\n                return;\r\n            }\r\n\r\n            switch (state.mode) {\r\n                case 'search':\r\n                    this.updateTitleForSearchState();\r\n                    break;\r\n                case 'sort':\r\n                    this.updateTitleForSortState();\r\n                    break;\r\n                default:\r\n                    this.updateTitleForNormalState();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Public API\r\n    return {\r\n        /**\r\n         * Initialize the TableTitleModule\r\n         */\r\n        initialize() {\r\n            if (!instance) {\r\n                instance = new TableTitleManager();\r\n            }\r\n            return instance;\r\n        },\r\n\r\n        /**\r\n         * Get the singleton instance\r\n         */\r\n        getInstance() {\r\n            return instance;\r\n        },\r\n\r\n        /**\r\n         * Force title refresh based on current state\r\n         */\r\n        refreshTitle() {\r\n            return instance?.refreshTitle();\r\n        },\r\n\r\n        /**\r\n         * Get current state information\r\n         */\r\n        getState() {\r\n            return { ...state };\r\n        }\r\n    };\r\n})();"]}